local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- // CONFIGURATION \\ --
local CONFIG = {
    Enabled = true,
    GameMode = "OneByOne", -- Defaults to OneByOne as requested, toggle available
    
    Strategy = "Shortest", 
    TargetEnding = "", 
    
    MinWordLength = 4,
    MaxWordLength = 35,
    
    RoundDuration = 15,
    PanicThreshold = 5,
    SafeModeThreshold = 8,
    
    SpeedMultiplier = 1.0, 
    
    ReactionMin = 0.5, -- Slightly faster for 1x1
    ReactionMax = 1.0,
    
    SubmitDelay = 0.05, 
    VerificationDelay = 0.6,
}

-- // DICTIONARY SYSTEM \\ --
local STARTER_WORDS = {
    A={"apple","about"}, B={"basic","bread"}, C={"catch","clean"}, D={"dance","drive"},
    E={"early","entry"}, F={"faith","field"}, G={"game","great","group","guard","guess"},
    H={"happy","heart"}, I={"image","index"}, J={"joint","judge"}, K={"knife","knock"},
    L={"label","laugh"}, M={"magic","money"}, N={"never","night"}, O={"ocean","order"},
    P={"paper","phone"}, Q={"queen","quiet"}, R={"radio","range"}, S={"scale","sound"},
    T={"table","thing"}, U={"uncle","under"}, V={"value","voice"}, W={"water","world"},
    X={"xenon","xerox"}, Y={"year","young"}, Z={"zebra","zone"}
}

local WORD_DATABASE = STARTER_WORDS
local usedWords = {}

task.spawn(function()
    local url = "https://raw.githubusercontent.com/Aktron01/jsonwords/refs/heads/main/mainword.json" 
    local success, response = pcall(function() return game:HttpGet(url) end)
    
    if success and response then
        local newDB = {}
        local count = 0
        for word in response:gmatch('"([%a]+)":') do
            if #word >= CONFIG.MinWordLength then
                local first = word:sub(1,1):upper()
                if not newDB[first] then newDB[first] = {} end
                table.insert(newDB[first], word)
                count = count + 1
            end
        end
        for letter, list in pairs(STARTER_WORDS) do
            if not newDB[letter] then newDB[letter] = {} end
            for _, word in ipairs(list) do table.insert(newDB[letter], word) end
        end
        if count > 0 then WORD_DATABASE = newDB end
    end
end)

-- // GLOBAL STATE \\ --
local TurnStartTime = 0
local isProcessing = false 
local lastProcessTime = 0 
local currentTurnBase = "" 

-- // HELPERS \\ --

local function getValidWord(prefix)
    if not prefix then prefix = "" end
    local searchPrefix = prefix
    local startLetter
    
    if searchPrefix == "" then
        local letters = {"A","B","C","S","T","M"}
        startLetter = letters[math.random(1, #letters)]
    else
        startLetter = searchPrefix:sub(1, 1):upper()
    end

    local words = WORD_DATABASE[startLetter]
    if not words then return nil end
    
    local validWords = {}
    local prefixLower = searchPrefix:lower()
    local prefixLen = #searchPrefix
    local avoidTrapWords = (CONFIG.Strategy == "Target" and CONFIG.TargetEnding:lower() == "x")

    for _, word in ipairs(words) do
        if #word >= prefixLen and #word <= CONFIG.MaxWordLength then
            if word:sub(1, prefixLen):lower() == prefixLower then
                local wordLower = word:lower()
                local isSafe = true
                if avoidTrapWords then
                    local ending = wordLower:sub(-2)
                    if ending == "ax" or ending == "ex" or ending == "ox" then isSafe = false end
                end
                if isSafe and not usedWords[wordLower] then
                    table.insert(validWords, wordLower)
                end
            end
        end
    end
    
    -- Fallback
    if #validWords == 0 then
        for _, word in ipairs(words) do
            if word:sub(1, prefixLen):lower() == prefixLower then
                 table.insert(validWords, word:lower())
            end
        end
    end
    
    if #validWords == 0 then return nil end
    
    local timeLeft = CONFIG.RoundDuration - (tick() - TurnStartTime)
    local forceShort = timeLeft < CONFIG.SafeModeThreshold
    
    table.sort(validWords, function(a, b)
        if forceShort then return #a < #b end
        if CONFIG.Strategy == "Longest" then return #a > #b end
        if CONFIG.Strategy == "Shortest" then return #a < #b end
        return #a < #b
    end)
    
    if CONFIG.Strategy == "Random" and not forceShort then
        return validWords[math.random(1, #validWords)]
    else
        return validWords[1]
    end
end

local function randomFloat(min, max) return min + math.random() * (max - min) end

local function typeLetter(letter)
    local keyCode = Enum.KeyCode[string.upper(letter)]
    if keyCode then
        VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
        task.wait()
        VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
    end
end

local function typeWord(word)
    local len = #word
    local targetDuration = (len <= 4 and 2.0 or 4.0) / CONFIG.SpeedMultiplier
    local avgDelay = targetDuration / len
    
    for i = 1, len do
        if CONFIG.RoundDuration - (tick() - TurnStartTime) < CONFIG.PanicThreshold then
            typeLetter(string.sub(word, i, i))
            task.wait()
        else
            task.wait(avgDelay * randomFloat(0.8, 1.2))
            typeLetter(string.sub(word, i, i))
        end
    end
end

local function submitWord()
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
    task.wait(0.02)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
end

local function clearText(count)
    for i = 1, count do 
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Backspace, false, game)
        task.wait() 
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Backspace, false, game)
    end
end

-- // READING UI \\ --

local function getGameFrame()
    local success, frame = pcall(function() return PlayerGui.InGame.Frame end)
    return success and frame or nil
end

local function scanForUsedWords()
    local frame = getGameFrame()
    if not frame then return end
    pcall(function()
        for _, descendant in ipairs(frame:GetDescendants()) do
            if descendant:IsA("TextLabel") and descendant.Visible then
                local cleanWord = descendant.Text:match("^%s*([%a]+)%s*$")
                if cleanWord and #cleanWord >= CONFIG.MinWordLength then
                    usedWords[cleanWord:lower()] = true
                end
            end
        end
    end)
end

local function getRequiredLetterLabel()
    local frame = getGameFrame()
    if not frame then return nil end
    local typeLabel = frame:FindFirstChild("Type")
    if typeLabel and typeLabel:IsA("TextLabel") then
        local text = typeLabel.Text
        local letter = text:match("starting with:%s*(%a)")
        if letter then return letter:upper() end
        letter = text:match("can form a word with:%s*(%a)")
        if letter then return letter:upper() end
    end
    return nil
end

local function getCurrentPrefix()
    local frame = getGameFrame()
    if not frame then return "" end
    local currentWord = frame:FindFirstChild("CurrentWord")
    if not currentWord then return "" end
    
    local text = ""
    local index = 1
    while true do
        local charFrame = currentWord:FindFirstChild(tostring(index))
        if not charFrame then break end
        if charFrame:IsA("Frame") and charFrame.Visible then
            local letterLabel = charFrame:FindFirstChild("Letter")
            if letterLabel then text = text .. letterLabel.Text end
        end
        index = index + 1
    end
    return text
end

local function isOurTurn()
    local frame = getGameFrame()
    if not frame or not frame.Visible then return false end
    local circle = frame:FindFirstChild("Circle")
    if not circle or not circle.Visible then return false end
    local typeLabel = frame:FindFirstChild("Type")
    if typeLabel and typeLabel:IsA("TextLabel") then
        local text = typeLabel.Text:lower()
        if string.find(text, LocalPlayer.DisplayName:lower()) or 
           string.find(text, LocalPlayer.Name:lower()) or 
           string.find(text, "your turn") then
            return true
        end
    end
    return false
end

-- // MAIN LOGIC \\ --
local lastTurnState = false

local function autoPlay()
    if isProcessing then 
        if tick() - lastProcessTime > 5 then isProcessing = false end
        return 
    end
    if not CONFIG.Enabled then return end
    
    scanForUsedWords()
    
    local myTurn = isOurTurn()
    if myTurn and not lastTurnState then
        TurnStartTime = tick()
        task.wait(0.1) 
        currentTurnBase = getRequiredLetterLabel() or ""
        if currentTurnBase == "" then currentTurnBase = getCurrentPrefix() end
    end
    lastTurnState = myTurn
    
    if not myTurn then return end
    
    isProcessing = true
    lastProcessTime = tick() 
    
    for attempt = 1, 4 do 
        if not isOurTurn() then break end 
        
        -- VISUAL PREFIX: What is physically on the screen (e.g. "" or "A")
        local visualPrefix = getCurrentPrefix()
        
        -- SEARCH PREFIX: What we look up (e.g. if visual is "", use "A" from prompt)
        local searchPrefix = visualPrefix
        if searchPrefix == "" and currentTurnBase ~= "" then
            searchPrefix = currentTurnBase
        end
        
        -- Handle Empty Start in Classic Mode
        if searchPrefix == "" and CONFIG.GameMode == "Classic" then 
            task.wait(0.2)
        else
            local fullWord = getValidWord(searchPrefix)
            
            if not fullWord then 
                if #visualPrefix > #currentTurnBase and CONFIG.GameMode == "Classic" then
                      clearText(#visualPrefix - #currentTurnBase)
                      task.wait(0.3)
                else
                      task.wait(0.5)
                end
            else
                -- // EXECUTION \\ --
                if CONFIG.GameMode == "OneByOne" then
                    -- MATH FIX: Use Visual Length to determine next character index
                    -- If Visual is "" (0), we need char 1.
                    -- If Visual is "A" (1), we need char 2.
                    local nextIndex = #visualPrefix + 1
                    local letterToType = fullWord:sub(nextIndex, nextIndex)
                    
                    if letterToType and letterToType ~= "" then
                        -- Wait/Think Delay
                        local timeLeft = CONFIG.RoundDuration - (tick() - TurnStartTime)
                        if attempt == 1 and timeLeft > CONFIG.PanicThreshold then
                            task.wait(randomFloat(CONFIG.ReactionMin, CONFIG.ReactionMax))
                        end
                        
                        typeLetter(letterToType)
                        task.wait(CONFIG.SubmitDelay)
                        submitWord()
                        
                        -- Wait to ensure we don't spam
                        task.wait(0.6)
                        if not isOurTurn() then break end
                    else
                        break 
                    end
                else
                    -- CLASSIC
                    local suffix = fullWord:sub(#visualPrefix + 1)
                    if suffix ~= "" then
                        local timeLeft = CONFIG.RoundDuration - (tick() - TurnStartTime)
                        if attempt == 1 and timeLeft > CONFIG.PanicThreshold then
                            task.wait(randomFloat(CONFIG.ReactionMin, CONFIG.ReactionMax))
                        end
                        typeWord(suffix)
                    end
                    task.wait(CONFIG.SubmitDelay)
                    submitWord()
                    task.wait(CONFIG.VerificationDelay)
                    if not isOurTurn() then usedWords[fullWord:lower()] = true; break end
                end
            end
        end
    end
    isProcessing = false
end

-- // MONITOR \\ --
task.spawn(function()
    while task.wait(0.1) do
        if CONFIG.Enabled then
            pcall(autoPlay)
        end
    end
end)

-- // UI \\ --
local function createUltimateUI()
    if PlayerGui:FindFirstChild("UltimateWordUI") then PlayerGui.UltimateWordUI:Destroy() end
    local screenGui = Instance.new("ScreenGui"); screenGui.Name = "UltimateWordUI"; screenGui.ResetOnSpawn = false; screenGui.Parent = PlayerGui
    local frame = Instance.new("Frame"); frame.Size = UDim2.new(0, 220, 0, 360); frame.Position = UDim2.new(0, 20, 0.5, -180); frame.BackgroundColor3 = Color3.fromRGB(20, 20, 25); frame.Parent = screenGui
    frame.Active = true; frame.Draggable = true
    Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 10)
    
    local function createBtn(text, pos, color, callback)
        local btn = Instance.new("TextButton")
        btn.Size = UDim2.new(0.9, 0, 0, 35); btn.Position = pos; btn.BackgroundColor3 = color
        btn.Text = text; btn.TextColor3 = Color3.new(1,1,1); btn.Font = Enum.Font.GothamBold; btn.TextSize = 13
        btn.Parent = frame; Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)
        btn.MouseButton1Click:Connect(callback)
        return btn
    end

    local title = Instance.new("TextLabel", frame); title.Size = UDim2.new(1,0,0,30); title.Text = "Ultimate Solver v2.1"; title.TextColor3 = Color3.fromRGB(0,255,200); title.BackgroundTransparency = 1; title.Font = Enum.Font.GothamBlack; title.TextSize = 13

    local toggleBtn = createBtn("STATUS: ACTIVE", UDim2.new(0.05,0,0,40), Color3.fromRGB(0,180,100), function()
        CONFIG.Enabled = not CONFIG.Enabled
    end)
    
    local stratBtn = createBtn("STRAT: SHORTEST", UDim2.new(0.05,0,0,85), Color3.fromRGB(60,60,80), function()
        if CONFIG.Strategy == "Shortest" then CONFIG.Strategy = "Longest"
        elseif CONFIG.Strategy == "Longest" then CONFIG.Strategy = "Random"
        else CONFIG.Strategy = "Shortest" end
    end)
    
    local modeBtn = createBtn("TYPE: ONE-BY-ONE", UDim2.new(0.05,0,0,130), Color3.fromRGB(100,60,120), function()
        if CONFIG.GameMode == "Classic" then CONFIG.GameMode = "OneByOne" else CONFIG.GameMode = "Classic" end
    end)
    
    task.spawn(function()
        while task.wait(0.2) do
            toggleBtn.Text = CONFIG.Enabled and "STATUS: ACTIVE" or "STATUS: PAUSED"
            toggleBtn.BackgroundColor3 = CONFIG.Enabled and Color3.fromRGB(0,180,100) or Color3.fromRGB(180,60,60)
            stratBtn.Text = "STRAT: " .. CONFIG.Strategy:upper()
            modeBtn.Text = "TYPE: " .. CONFIG.GameMode:upper()
            modeBtn.BackgroundColor3 = (CONFIG.GameMode == "OneByOne") and Color3.fromRGB(100,60,120) or Color3.fromRGB(80,60,100)
        end
    end)
end

createUltimateUI()
