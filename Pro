local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TextChatService = game:GetService("TextChatService")
local LogService = game:GetService("LogService")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Mouse = LocalPlayer:GetMouse()

-- // ULTIMATE CONFIGURATION \\ --
local CONFIG = {
    Enabled = true,
    
    -- STRATEGY SETTINGS
    Strategy = "Shortest", 
    TargetEnding = "", 
    
    MinWordLength = 3, 
    MaxWordLength = 35,
    
    -- ROUND SETTINGS
    RoundDuration = 15,
    PanicThreshold = 4,   
    SafeModeThreshold = 6, 
    
    -- HUMANIZATION SETTINGS
    HumanMode = true,        
    SpeedMultiplier = 1.0, 
    
    -- REACTION DELAY (Seconds)
    ReactionMin = 0.4,
    ReactionMax = 0.8,
    
    MistakeChance = 0.08,        
    MicroPauseChance = 0.15,
    SubmitDelay = 0.05, 
    
    VerificationDelay = 0.8,
}

-- // UI COLORS \\ --
local STRATEGY_COLORS = {
    Shortest = Color3.fromRGB(0, 255, 128),
    Longest = Color3.fromRGB(255, 60, 60),
    Target = Color3.fromRGB(170, 85, 255),
    Random = Color3.fromRGB(255, 200, 50)
}

-- // DICTIONARY SYSTEM \\ --
local STARTER_WORDS = {
    A={"apple","about"}, B={"basic","bread"}, C={"catch","clean"}, D={"dance","drive"},
    E={"early","entry"}, F={"faith","field"}, G={"game","great","group","guard","guess"},
    H={"happy","heart"}, I={"image","index"}, J={"joint","judge"}, K={"knife","knock"},
    L={"label","laugh"}, M={"magic","money"}, N={"never","night"}, O={"ocean","order"},
    P={"paper","phone"}, Q={"queen","quiet"}, R={"radio","range"}, S={"scale","sound"},
    T={"table","thing"}, U={"uncle","under"}, V={"value","voice"}, W={"water","world"},
    X={"xenon","xerox"}, Y={"year","young"}, Z={"zebra","zone"}
}

local WORD_DATABASE = STARTER_WORDS
local usedWords = {}

-- [Dictionary Loader]
task.spawn(function()
    -- UPDATED MAIN URL
    local url = "https://raw.githubusercontent.com/Aktron01/word33/refs/heads/main/mainword.json"
    
    local success, response = pcall(function() return game:HttpGet(url) end)
    
    if not success or not response then 
        warn(" [Ultimate] Download failed. Using starter words.")
        return 
    end

    local newDB = {}
    local count = 0
    
    for word in response:gmatch('"([%a]+)":') do
        if #word >= CONFIG.MinWordLength then
            local first = word:sub(1,1):upper()
            if not newDB[first] then newDB[first] = {} end
            table.insert(newDB[first], word)
            count = count + 1
        end
    end
    
    for letter, list in pairs(STARTER_WORDS) do
        if not newDB[letter] then newDB[letter] = {} end
        for _, word in ipairs(list) do
            table.insert(newDB[letter], word)
        end
    end
    
    if count > 0 then
        WORD_DATABASE = newDB
        print(" [Ultimate] Loaded " .. count .. " words from Main URL.")
    end
end)

-- // GLOBAL STATE \\ --
local TurnStartTime = 0
local isProcessing = false 
local lastProcessTime = 0 
local currentTurnBase = "" 

-- // LOGIC FUNCTIONS \\ --

local function randomFloat(min, max)
    return min + math.random() * (max - min)
end

-- Function to send to public chat (Legacy or Modern)
local function sendToPublicChat(message)
    -- Method 1: Modern TextChatService
    if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
        local channel = TextChatService.TextChannels:FindFirstChild("RBXGeneral")
        if channel then
            channel:SendAsync(message)
            return
        end
    end

    -- Method 2: Legacy Chat Event
    local legacyEvent = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
    if legacyEvent then
        local sayRequest = legacyEvent:FindFirstChild("SayMessageRequest")
        if sayRequest then
            sayRequest:FireServer(message, "All")
            return
        end
    end
    
    warn("Could not find a valid chat method.")
end

local function typeLetter(letter, fastMode)
    local keyCode = Enum.KeyCode[string.upper(letter)]
    if keyCode then
        VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
        if not fastMode then
            task.wait(randomFloat(0.015, 0.035)) 
        end
        VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
    end
end

local function typeWord(word)
    local len = #word
    local targetDuration = 0
    
    if len <= 4 then targetDuration = randomFloat(1.5, 2.5)
    elseif len <= 9 then targetDuration = randomFloat(3.0, 5.0)
    else targetDuration = randomFloat(4.5, 8.0) end
    
    targetDuration = targetDuration / CONFIG.SpeedMultiplier 
    local avgDelay = targetDuration / len
    
    for i = 1, len do
        local timeLeft = 10 
        if TurnStartTime > 0 then
             timeLeft = CONFIG.RoundDuration - (tick() - TurnStartTime)
        end
        
        local isPanic = timeLeft < CONFIG.PanicThreshold
        local letter = string.sub(word, i, i)
        
        if isPanic then
            typeLetter(letter, true)
            task.wait() 
        else
            local currentDelay = avgDelay * randomFloat(0.7, 1.3)
            if CONFIG.Strategy ~= "Longest" and math.random() < CONFIG.MicroPauseChance and i > 1 then
                currentDelay = currentDelay + randomFloat(0.15, 0.3)
            end
            task.wait(currentDelay)
            typeLetter(letter, false)
        end
    end
end

local function submitWord()
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
    task.wait(0.02)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
end

-- // WORD SEARCH LOGIC \\ --

local function getMatchingWords(prefix)
    if not prefix or prefix == "" then return {} end
    local startLetter = prefix:sub(1, 1):upper()
    local words = WORD_DATABASE[startLetter]
    
    if not words then return {} end
    
    local matches = {}
    local prefixLower = prefix:lower()
    local prefixLen = #prefix
    local avoidTrapWords = (CONFIG.Strategy == "Target" and CONFIG.TargetEnding:lower() == "x")
    
    for _, word in ipairs(words) do
        if #word >= prefixLen and #word <= CONFIG.MaxWordLength then
            if word:sub(1, prefixLen):lower() == prefixLower then
                local wordLower = word:lower()
                local isSafe = true
                if avoidTrapWords then
                    local ending = wordLower:sub(-2)
                    if ending == "ax" or ending == "ex" or ending == "ox" then isSafe = false end
                end

                if isSafe and not usedWords[wordLower] then
                    table.insert(matches, wordLower)
                end
            end
        end
    end
    
    return matches
end

local function getValidWord(prefix)
    local possibilities = getMatchingWords(prefix) 
    if #possibilities == 0 then return nil end
    
    local timeElapsed = tick() - TurnStartTime
    local timeLeft = CONFIG.RoundDuration - timeElapsed
    local forceShort = (timeLeft < CONFIG.SafeModeThreshold)
    
    table.sort(possibilities, function(a, b)
        if forceShort then return #a < #b end
        if CONFIG.Strategy == "Target" and CONFIG.TargetEnding ~= "" then
            local target = CONFIG.TargetEnding:lower()
            local aEnds = a:sub(-1) == target
            local bEnds = b:sub(-1) == target
            if aEnds and not bEnds then return true end
            if not aEnds and bEnds then return false end
        end
        if CONFIG.Strategy == "Longest" then return #a > #b end 
        if CONFIG.Strategy == "Shortest" then return #a < #b end
        return false 
    end)
    
    if CONFIG.Strategy == "Random" and not forceShort then
        return possibilities[math.random(1, #possibilities)]
    else
        return possibilities[1]
    end
end

-- // GAME STATE DETECTION \\ --

local function getGameFrame()
    local success, frame = pcall(function()
        return PlayerGui.InGame.Frame
    end)
    return success and frame or nil
end

local function scanForUsedWords()
    local frame = getGameFrame()
    if not frame then return end
    pcall(function()
        for _, descendant in ipairs(frame:GetDescendants()) do
            if descendant:IsA("TextLabel") and descendant.Visible then
                local text = descendant.Text
                local cleanWord = text:match("^%s*([%a]+)%s*$")
                if cleanWord and #cleanWord >= CONFIG.MinWordLength then
                    usedWords[cleanWord:lower()] = true
                end
            end
        end
    end)
end

local function getRequiredLetterLabel()
    local frame = getGameFrame()
    if not frame then return nil end
    local typeLabel = frame:FindFirstChild("Type")
    if typeLabel and typeLabel:IsA("TextLabel") then
        local text = typeLabel.Text
        local letter = text:match("starting with:%s*(%a)")
        if letter then return letter:upper() end
        letter = text:match("can form a word with:%s*(%a)")
        if letter then return letter:upper() end
    end
    return nil
end

local function getCurrentPrefix()
    local frame = getGameFrame()
    if not frame then return "" end
    local currentWord = frame:FindFirstChild("CurrentWord")
    if not currentWord then return "" end
    local text = ""
    local index = 1
    while true do
        local charFrame = currentWord:FindFirstChild(tostring(index))
        if not charFrame then break end
        if charFrame:IsA("Frame") and charFrame.Visible then
            local letterLabel = charFrame:FindFirstChild("Letter")
            if letterLabel then text = text .. letterLabel.Text end
        end
        index = index + 1
    end
    return text
end

local function isOurTurn()
    local frame = getGameFrame()
    if not frame or not frame.Visible then return false end
    local circle = frame:FindFirstChild("Circle")
    if not circle or not circle.Visible then return false end
    local typeLabel = frame:FindFirstChild("Type")
    if typeLabel and typeLabel:IsA("TextLabel") then
        local text = typeLabel.Text
        if string.find(text, LocalPlayer.DisplayName) or string.find(text, LocalPlayer.Name) or string.find(text:lower(), "your turn") then
            return true
        end
    end
    return false
end

-- // ULTIMATE GUI & SUGGESTION BOX \\ --
local suggestionFrame
local updateSuggestions 

local function createUltimateUI()
    if PlayerGui:FindFirstChild("UltimateWordUI") then
        PlayerGui.UltimateWordUI:Destroy()
    end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "UltimateWordUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = PlayerGui
    
    -- MAIN FRAME
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 240, 0, 320) 
    frame.Position = UDim2.new(0, 20, 0.5, -160)
    frame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    frame.BorderSizePixel = 0
    frame.Active = true
    frame.Draggable = true
    frame.Parent = screenGui
    
    local uiCorner = Instance.new("UICorner"); uiCorner.CornerRadius = UDim.new(0, 10); uiCorner.Parent = frame
    
    -- SUGGESTION BOX
    suggestionFrame = Instance.new("Frame")
    suggestionFrame.Size = UDim2.new(0, 220, 0, 320) 
    suggestionFrame.Position = UDim2.new(1, 10, 0, 0) 
    suggestionFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
    suggestionFrame.BorderSizePixel = 0
    suggestionFrame.Parent = frame
    local sgCorner = Instance.new("UICorner"); sgCorner.CornerRadius = UDim.new(0, 10); sgCorner.Parent = suggestionFrame
    
    local sgTitle = Instance.new("TextLabel")
    sgTitle.Size = UDim2.new(1, 0, 0, 30)
    sgTitle.BackgroundTransparency = 1
    sgTitle.Text = "MANUAL ASSIST"
    sgTitle.TextColor3 = Color3.fromRGB(0, 200, 255)
    sgTitle.Font = Enum.Font.GothamBlack
    sgTitle.TextSize = 12
    sgTitle.Parent = suggestionFrame

    local listLayout = Instance.new("UIListLayout")
    listLayout.Parent = suggestionFrame
    listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    listLayout.Padding = UDim.new(0, 5)

    local padding = Instance.new("UIPadding")
    padding.PaddingTop = UDim.new(0, 35)
    padding.Parent = suggestionFrame

    -- Function to refresh the suggestions
    updateSuggestions = function(prefix)
        for _, child in pairs(suggestionFrame:GetChildren()) do
            if child:IsA("Frame") then child:Destroy() end 
            if child:IsA("TextButton") then child:Destroy() end 
        end

        local words = getMatchingWords(prefix)
        table.sort(words, function(a,b) return #a < #b end)
        
        if #words == 0 then
            local info = Instance.new("TextButton")
            info.Size = UDim2.new(0.9, 0, 0, 40)
            info.BackgroundTransparency = 1
            info.Text = (prefix == "") and "Waiting..." or "No words found"
            info.TextColor3 = Color3.fromRGB(100,100,100)
            info.Font = Enum.Font.Gotham
            info.TextSize = 12
            info.Parent = suggestionFrame
            return
        end

        local limit = 6
        for i = 1, math.min(#words, limit) do
            local word = words[i]
            
            -- CONTAINER ROW
            local row = Instance.new("Frame")
            row.Size = UDim2.new(0.95, 0, 0, 40)
            row.BackgroundColor3 = Color3.fromRGB(40, 45, 60)
            row.Parent = suggestionFrame
            local rCorner = Instance.new("UICorner"); rCorner.CornerRadius = UDim.new(0,6); rCorner.Parent = row
            
            -- WORD LABEL (Left)
            local wordLbl = Instance.new("TextLabel")
            wordLbl.Size = UDim2.new(0.45, 0, 1, 0)
            wordLbl.Position = UDim2.new(0, 5, 0, 0)
            wordLbl.BackgroundTransparency = 1
            wordLbl.Text = word:upper()
            wordLbl.TextColor3 = Color3.fromRGB(255, 255, 255)
            wordLbl.Font = Enum.Font.GothamBold
            wordLbl.TextSize = 12
            wordLbl.TextXAlignment = Enum.TextXAlignment.Left
            wordLbl.Parent = row
            
            -- PLAY BUTTON (Green - Middle)
            local playBtn = Instance.new("TextButton")
            playBtn.Size = UDim2.new(0.25, 0, 0.8, 0)
            playBtn.Position = UDim2.new(0.45, 0, 0.1, 0)
            playBtn.BackgroundColor3 = Color3.fromRGB(0, 180, 100)
            playBtn.Text = "PLAY"
            playBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
            playBtn.Font = Enum.Font.GothamBlack
            playBtn.TextSize = 10
            playBtn.Parent = row
            local pCorner = Instance.new("UICorner"); pCorner.CornerRadius = UDim.new(0,4); pCorner.Parent = playBtn
            
            -- CHAT BUTTON (Blue - Right)
            local chatBtn = Instance.new("TextButton")
            chatBtn.Size = UDim2.new(0.25, 0, 0.8, 0)
            chatBtn.Position = UDim2.new(0.72, 0, 0.1, 0)
            chatBtn.BackgroundColor3 = Color3.fromRGB(60, 100, 255)
            chatBtn.Text = "CHAT"
            chatBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
            chatBtn.Font = Enum.Font.GothamBlack
            chatBtn.TextSize = 10
            chatBtn.Parent = row
            local cCorner = Instance.new("UICorner"); cCorner.CornerRadius = UDim.new(0,4); cCorner.Parent = chatBtn
            
            -- PLAY LOGIC (Existing)
            playBtn.MouseButton1Click:Connect(function()
                task.spawn(function()
                    usedWords[word:lower()] = true
                    local currentP = getCurrentPrefix()
                    local suffix = word
                    if #currentP > 0 and word:lower():sub(1, #currentP) == currentP:lower() then
                        suffix = word:sub(#currentP + 1)
                    end
                    playBtn.Text = "..."
                    playBtn.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
                    if suffix ~= "" then typeWord(suffix) end
                    task.wait(CONFIG.SubmitDelay)
                    submitWord()
                    playBtn.BackgroundColor3 = Color3.fromRGB(0, 255, 100) 
                    playBtn.Text = "DONE"
                end)
            end)

            -- CHAT LOGIC (New)
            chatBtn.MouseButton1Click:Connect(function()
                chatBtn.Text = "..."
                sendToPublicChat("Try: " .. word:upper())
                task.wait(0.5)
                chatBtn.Text = "SENT"
                task.wait(0.5)
                chatBtn.Text = "CHAT"
            end)
        end
    end

    -- UI ELEMENTS
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 30)
    title.BackgroundTransparency = 1
    title.Text = "AutoPlay v10 + Chat Assist"
    title.TextColor3 = Color3.fromRGB(0, 255, 200)
    title.Font = Enum.Font.GothamBlack
    title.TextSize = 13
    title.Parent = frame
    
    local toggleBtn = Instance.new("TextButton")
    toggleBtn.Size = UDim2.new(0.9, 0, 0, 35)
    toggleBtn.Position = UDim2.new(0.05, 0, 0, 40)
    toggleBtn.BackgroundColor3 = CONFIG.Enabled and Color3.fromRGB(0, 180, 100) or Color3.fromRGB(180, 60, 60)
    toggleBtn.Text = CONFIG.Enabled and "STATUS: ACTIVE" or "STATUS: PAUSED"
    toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleBtn.Font = Enum.Font.GothamBold
    toggleBtn.TextSize = 14
    toggleBtn.Parent = frame
    local tCorner = Instance.new("UICorner"); tCorner.CornerRadius = UDim.new(0,6); tCorner.Parent = toggleBtn
    
    local strategyBtn = Instance.new("TextButton")
    strategyBtn.Size = UDim2.new(0.9, 0, 0, 35)
    strategyBtn.Position = UDim2.new(0.05, 0, 0, 85)
    strategyBtn.BackgroundColor3 = STRATEGY_COLORS[CONFIG.Strategy] or Color3.fromRGB(60,60,80)
    strategyBtn.Text = "MODE: " .. CONFIG.Strategy:upper()
    strategyBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    strategyBtn.Font = Enum.Font.GothamBold
    strategyBtn.TextSize = 13
    strategyBtn.Parent = frame
    local sCorner = Instance.new("UICorner"); sCorner.CornerRadius = UDim.new(0,6); sCorner.Parent = strategyBtn

    local sliderLabel = Instance.new("TextLabel")
    sliderLabel.Size = UDim2.new(1, 0, 0, 15)
    sliderLabel.Position = UDim2.new(0, 0, 0, 130)
    sliderLabel.Text = "Typing Speed: 1.0x"
    sliderLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    sliderLabel.BackgroundTransparency = 1
    sliderLabel.Font = Enum.Font.GothamBold
    sliderLabel.TextSize = 11
    sliderLabel.Parent = frame
    
    local sliderBg = Instance.new("Frame")
    sliderBg.Size = UDim2.new(0.9, 0, 0, 8)
    sliderBg.Position = UDim2.new(0.05, 0, 0, 150)
    sliderBg.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    sliderBg.Parent = frame
    local slCorner = Instance.new("UICorner"); slCorner.CornerRadius = UDim.new(1,0); slCorner.Parent = sliderBg
    
    local sliderFill = Instance.new("Frame")
    sliderFill.Size = UDim2.new(0.2, 0, 1, 0)
    sliderFill.BackgroundColor3 = Color3.fromRGB(0, 200, 255)
    sliderFill.Parent = sliderBg
    local sfCorner = Instance.new("UICorner"); sfCorner.CornerRadius = UDim.new(1,0); sfCorner.Parent = sliderFill
    
    local sliderBtn = Instance.new("TextButton")
    sliderBtn.Size = UDim2.new(1, 0, 1, 0)
    sliderBtn.BackgroundTransparency = 1
    sliderBtn.Text = ""
    sliderBtn.Parent = sliderBg
    
    local dragging = false
    local minSpeed = 0.5
    local maxSpeed = 5.0
    
    sliderBtn.MouseButton1Down:Connect(function() dragging = true end)
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local mousePos = UserInputService:GetMouseLocation().X
            local framePos = sliderBg.AbsolutePosition.X
            local frameSize = sliderBg.AbsoluteSize.X
            local relativePos = math.clamp((mousePos - framePos) / frameSize, 0, 1)
            
            sliderFill.Size = UDim2.new(relativePos, 0, 1, 0)
            local newSpeed = minSpeed + (relativePos * (maxSpeed - minSpeed))
            newSpeed = math.floor(newSpeed * 10) / 10 
            
            CONFIG.SpeedMultiplier = newSpeed
            sliderLabel.Text = "Typing Speed: " .. newSpeed .. "x"
        end
    end)

    local targetBox = Instance.new("TextBox")
    targetBox.Size = UDim2.new(0.9, 0, 0, 30)
    targetBox.Position = UDim2.new(0.05, 0, 0, 190)
    targetBox.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    targetBox.Text = ""
    targetBox.PlaceholderText = "Target Letter (e.g. X)"
    targetBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    targetBox.Font = Enum.Font.Gotham
    targetBox.TextSize = 12
    targetBox.Parent = frame
    local tbCorner = Instance.new("UICorner"); tbCorner.CornerRadius = UDim.new(0,6); tbCorner.Parent = targetBox

    local resetBtn = Instance.new("TextButton")
    resetBtn.Size = UDim2.new(0.9, 0, 0, 30)
    resetBtn.Position = UDim2.new(0.05, 0, 0, 230)
    resetBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 50)
    resetBtn.Text = "RESET MEMORY"
    resetBtn.TextColor3 = Color3.fromRGB(255, 200, 200)
    resetBtn.Font = Enum.Font.GothamBold
    resetBtn.TextSize = 12
    resetBtn.Parent = frame
    local rCorner = Instance.new("UICorner"); rCorner.CornerRadius = UDim.new(0,6); rCorner.Parent = resetBtn
    
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Size = UDim2.new(1, 0, 0, 20)
    statusLabel.Position = UDim2.new(0, 0, 0, 275)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Text = "Waiting..."
    statusLabel.TextColor3 = Color3.fromRGB(120, 120, 120)
    statusLabel.Font = Enum.Font.Gotham
    statusLabel.TextSize = 11
    statusLabel.Parent = frame

    -- EVENTS
    toggleBtn.MouseButton1Click:Connect(function()
        CONFIG.Enabled = not CONFIG.Enabled
        toggleBtn.BackgroundColor3 = CONFIG.Enabled and Color3.fromRGB(0, 180, 100) or Color3.fromRGB(180, 60, 60)
        toggleBtn.Text = CONFIG.Enabled and "STATUS: ACTIVE" or "STATUS: PAUSED"
    end)
    
    local strategies = {"Shortest", "Longest", "Target", "Random"}
    local sIndex = 1
    strategyBtn.MouseButton1Click:Connect(function()
        sIndex = sIndex + 1
        if sIndex > #strategies then sIndex = 1 end
        CONFIG.Strategy = strategies[sIndex]
        strategyBtn.Text = "MODE: " .. CONFIG.Strategy:upper()
        
        -- UPDATE COLOR HERE
        if STRATEGY_COLORS[CONFIG.Strategy] then
            strategyBtn.BackgroundColor3 = STRATEGY_COLORS[CONFIG.Strategy]
        end
    end)
    
    targetBox:GetPropertyChangedSignal("Text"):Connect(function()
        if #targetBox.Text > 1 then targetBox.Text = targetBox.Text:sub(1,1) end
        CONFIG.TargetEnding = targetBox.Text
    end)
    
    resetBtn.MouseButton1Click:Connect(function()
        usedWords = {}
        resetBtn.Text = "CLEARED!"
        task.wait(1)
        resetBtn.Text = "RESET MEMORY"
    end)

    -- Toggle Logic: Left OR Right Control
    UserInputService.InputBegan:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.RightControl or input.KeyCode == Enum.KeyCode.LeftControl then
            frame.Visible = not frame.Visible
        end
    end)
    
    -- Status Loop Update
    task.spawn(function()
        while task.wait(0.2) do
            if screenGui.Parent and isOurTurn() then
                local timeLeft = CONFIG.RoundDuration - (tick() - TurnStartTime)
                statusLabel.Text = "YOUR TURN: " .. math.floor(timeLeft) .. "s"
                statusLabel.TextColor3 = (timeLeft < CONFIG.PanicThreshold) and Color3.fromRGB(255, 50, 50) or Color3.fromRGB(0, 255, 0)
            else
                statusLabel.Text = "Scanning..."
                statusLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
            end
        end
    end)
end

-- // MAIN LOGIC LOOPS \\ --

local lastTurnState = false
local lastKnownPrefix = ""

-- 1. Game State Monitor (Always runs, updates UI)
task.spawn(function()
    while task.wait(0.1) do
        local myTurn = isOurTurn()
        local prefix = getCurrentPrefix()
        
        if myTurn and not lastTurnState then
            TurnStartTime = tick()
            task.wait(0.1)
            if prefix == "" then
                local req = getRequiredLetterLabel()
                if req then prefix = req end
            end
            currentTurnBase = prefix
        end
        
        if prefix == "" and currentTurnBase ~= "" and myTurn then
            prefix = currentTurnBase
        end

        if prefix ~= lastKnownPrefix or myTurn ~= lastTurnState then
            if updateSuggestions then
                updateSuggestions(prefix)
            end
            lastKnownPrefix = prefix
        end
        
        lastTurnState = myTurn
        scanForUsedWords()
    end
end)

-- 2. AutoPlay Bot Logic
task.spawn(function()
    while task.wait(0.1) do
        if CONFIG.Enabled and isOurTurn() and not isProcessing then
            isProcessing = true
            local prefix = getCurrentPrefix()
            if prefix == "" then prefix = currentTurnBase end
            
            if prefix ~= "" then
                local fullWord = getValidWord(prefix)
                if fullWord then
                    task.wait(randomFloat(CONFIG.ReactionMin, CONFIG.ReactionMax))
                    if isOurTurn() then
                        local suffix = fullWord:sub(#prefix + 1)
                        if suffix ~= "" then typeWord(suffix) end
                        task.wait(CONFIG.SubmitDelay)
                        submitWord()
                        usedWords[fullWord:lower()] = true
                        task.wait(CONFIG.VerificationDelay)
                    end
                end
            end
            isProcessing = false
        end
    end
end)

createUltimateUI()
print(" [Ultimate] Loaded with PLAY and CHAT buttons (GitHub URL Updated).")
