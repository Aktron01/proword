local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LogService = game:GetService("LogService")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- // CONFIGURATION \\ --
local CONFIG = {
    Enabled = true,
    Strategy = "Shortest", -- Options: "Shortest", "Longest", "Target", "Random"
    TargetEnding = "", 
    MinWordLength = 2,
    MaxWordLength = 35,
    
    -- TYPING SETTINGS
    HumanMode = true,        
    ReactionMin = 0.5,      
    ReactionMax = 1.0,      
    SubmitDelay = 0.1,        
}

-- // DICTIONARY SYSTEM \\ --
local STARTER_WORDS = {
    A = { "apple", "about", "after", "again", "alarm", "allow", "angry", "apart", "apple", "apply", "aware" },
    B = { "basic", "beach", "begin", "black", "block", "board", "boost", "bound", "brain", "brake", "bread" },
    C = { "catch", "cause", "chain", "chair", "chart", "chase", "cheap", "check", "child", "class", "clean" },
    D = { "dance", "death", "depth", "doubt", "draft", "drain", "dream", "dress", "drink", "drive", "drove" },
    E = { "early", "earth", "eight", "empty", "enemy", "enjoy", "enter", "entry", "equal", "error", "event" },
    F = { "faith", "false", "fault", "favor", "fence", "field", "fight", "final", "first", "flame", "flash" },
    S = { "scale", "scene", "scope", "score", "sense", "serve", "seven", "shade", "shake", "share", "sharp" },
    T = { "table", "taste", "teach", "thank", "theme", "there", "thick", "thing", "think", "third", "those" },
    W = { "waste", "watch", "water", "where", "which", "while", "white", "whole", "whose", "woman", "world" }
}

local WORD_DATABASE = STARTER_WORDS
local usedWords = {}

-- [Safe Dictionary Loader]
task.spawn(function()
    local url = "https://raw.githubusercontent.com/dwyl/english-words/refs/heads/master/words_dictionary.json"
    print(" [AutoPlay] Downloading Dictionary...")
    
    local success, response = pcall(function() return game:HttpGet(url) end)
    
    if not success or not response then 
        warn(" [AutoPlay] Download failed. Using starter words.")
        return 
    end

    local newDB = {}
    local count = 0
    
    for word in response:gmatch('"([%a]+)":') do
        if #word >= CONFIG.MinWordLength then
            local first = word:sub(1,1):upper()
            if not newDB[first] then newDB[first] = {} end
            table.insert(newDB[first], word)
            count = count + 1
        end
    end
    
    -- Add starter words to be safe
    for letter, list in pairs(STARTER_WORDS) do
        if not newDB[letter] then newDB[letter] = {} end
        for _, word in ipairs(list) do
            table.insert(newDB[letter], word)
        end
    end
    
    if count > 0 then
        WORD_DATABASE = newDB
        print(" [AutoPlay] Loaded " .. count .. " words.")
    end
end)

-- // LOGIC FUNCTIONS \\ --

local function getValidWord(prefix)
    if not prefix or prefix == "" then return nil end
    local startLetter = prefix:sub(1, 1):upper()
    local words = WORD_DATABASE[startLetter]
    if not words then return nil end
    
    local validWords = {}
    local prefixLower = prefix:lower()
    local prefixLen = #prefix
    
    for _, word in ipairs(words) do
        if #word >= prefixLen and #word <= CONFIG.MaxWordLength then
            if word:sub(1, prefixLen):lower() == prefixLower then
                if not usedWords[word:lower()] then
                    table.insert(validWords, word:lower())
                end
            end
        end
    end
    
    -- Fallback: Reuse words if necessary
    if #validWords == 0 then
        for _, word in ipairs(words) do
            if word:sub(1, prefixLen):lower() == prefixLower then
                table.insert(validWords, word:lower())
            end
        end
    end
    
    if #validWords == 0 then return nil end
    
    -- Sorting Strategy
    table.sort(validWords, function(a, b)
        if CONFIG.Strategy == "Target" and CONFIG.TargetEnding ~= "" then
            local target = CONFIG.TargetEnding:lower()
            local aEnds = a:sub(-1) == target
            local bEnds = b:sub(-1) == target
            if aEnds and not bEnds then return true end
            if not aEnds and bEnds then return false end
        end
        if CONFIG.Strategy == "Longest" then return #a > #b end
        if CONFIG.Strategy == "Shortest" then return #a < #b end
        return false 
    end)
    
    local selectedWord = (CONFIG.Strategy == "Random") and validWords[math.random(1, #validWords)] or validWords[1]
    usedWords[selectedWord] = true
    return selectedWord
end

local function typeLetter(letter)
    local keyCode = Enum.KeyCode[string.upper(letter)]
    if keyCode then
        VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
        task.wait(0.015) -- Fast key press
        VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
    end
end

local function typeWord(word)
    local delayPerChar = 0.05 -- Speed (Lower is faster)
    
    if CONFIG.Strategy == "Shortest" then delayPerChar = 0.03 end
    if CONFIG.Strategy == "Longest" then delayPerChar = 0.02 end -- Go fast for long words
    
    for i = 1, #word do
        typeLetter(string.sub(word, i, i))
        task.wait(delayPerChar + math.random() * 0.02)
    end
end

local function submitWord()
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
    task.wait(0.05)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
end

-- // DETECTION HELPERS \\ --

-- Helper to find the game UI safely
local function getGameFrame()
    local success, frame = pcall(function()
        return PlayerGui.InGame.Frame
    end)
    return success and frame or nil
end

local function getRequiredLetterLabel()
    local frame = getGameFrame()
    if not frame then return nil end
    
    local typeLabel = frame:FindFirstChild("Type")
    if typeLabel and typeLabel:IsA("TextLabel") then
        local text = typeLabel.Text
        local letter = text:match("starting with:%s*(%a)")
        if letter then return letter:upper() end
        letter = text:match("can form a word with:%s*(%a)")
        if letter then return letter:upper() end
    end
    return nil
end

local function getCurrentPrefix()
    local frame = getGameFrame()
    if not frame then return "" end
    
    local currentWord = frame:FindFirstChild("CurrentWord")
    if not currentWord then return "" end
    
    local text = ""
    local index = 1
    while true do
        local charFrame = currentWord:FindFirstChild(tostring(index))
        if not charFrame then break end
        if charFrame:IsA("Frame") and charFrame.Visible then
            local letterLabel = charFrame:FindFirstChild("Letter")
            if letterLabel then text = text .. letterLabel.Text end
        end
        index = index + 1
    end
    return text
end

local function isOurTurn()
    local frame = getGameFrame()
    if not frame or not frame.Visible then return false end
    
    local circle = frame:FindFirstChild("Circle")
    if not circle or not circle.Visible then return false end
    
    local typeLabel = frame:FindFirstChild("Type")
    if typeLabel and typeLabel:IsA("TextLabel") then
        local text = typeLabel.Text
        -- Check for common identifiers
        if string.find(text, LocalPlayer.DisplayName) or 
           string.find(text, LocalPlayer.Name) or 
           string.find(text:lower(), "your turn") then
            return true
        end
    end
    return false
end

-- // MAIN LOOP \\ --
local isProcessing = false
local lastPlayTime = 0

local function autoPlay()
    if isProcessing then return end
    if not CONFIG.Enabled then return end
    
    -- FIXED: We removed the strict "isInGame" attribute check. 
    -- If the UI is visible, we try to play.
    if not isOurTurn() then return end
    
    local now = tick()
    if now - lastPlayTime < 1.0 then return end 
    
    isProcessing = true
    lastPlayTime = now
    
    print(" [AutoPlay] It is our turn!")
    
    local prefix = getCurrentPrefix()
    if prefix == "" then
        local req = getRequiredLetterLabel()
        if req then prefix = req end
    end
    
    if prefix == "" then
        print(" [AutoPlay] Could not find prefix letters.")
        isProcessing = false
        return
    end
    
    local fullWord = getValidWord(prefix)
    if not fullWord then
        print(" [AutoPlay] No word found for: " .. prefix)
        isProcessing = false
        return
    end
    
    local suffix = fullWord:sub(#prefix + 1)
    
    print(" [AutoPlay] Typing: " .. fullWord)
    
    local reactionTime = math.random() * 0.5 + 0.5
    task.wait(reactionTime)
    
    if suffix ~= "" then
        typeWord(suffix)
    end
    
    task.wait(CONFIG.SubmitDelay)
    submitWord()
    
    isProcessing = false
end

task.spawn(function()
    while task.wait(0.1) do
        if CONFIG.Enabled then
            autoPlay()
        end
    end
end)

-- // UI SETUP \\ --
local function createUI()
    if PlayerGui:FindFirstChild("UniversalAutoPlay") then PlayerGui.UniversalAutoPlay:Destroy() end
    
    local gui = Instance.new("ScreenGui")
    gui.Name = "UniversalAutoPlay"
    gui.Parent = PlayerGui
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 180)
    frame.Position = UDim2.new(0, 20, 0.5, -90)
    frame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    frame.Active = true
    frame.Draggable = true
    frame.Parent = gui
    
    local title = Instance.new("TextLabel")
    title.Text = "AUTO PLAY FIX"
    title.Size = UDim2.new(1,0,0,30)
    title.TextColor3 = Color3.fromRGB(0, 255, 150)
    title.BackgroundTransparency = 1
    title.Parent = frame
    
    local status = Instance.new("TextLabel")
    status.Text = "Status: ON"
    status.Position = UDim2.new(0,0,0,40)
    status.Size = UDim2.new(1,0,0,30)
    status.TextColor3 = Color3.fromRGB(255,255,255)
    status.BackgroundTransparency = 1
    status.Parent = frame
    
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0.8, 0, 0, 40)
    btn.Position = UDim2.new(0.1, 0, 0, 80)
    btn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    btn.Text = "Toggle"
    btn.Parent = frame
    
    btn.MouseButton1Click:Connect(function()
        CONFIG.Enabled = not CONFIG.Enabled
        status.Text = CONFIG.Enabled and "Status: ON" or "Status: OFF"
        status.TextColor3 = CONFIG.Enabled and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,0,0)
    end)
    
    local resetBtn = Instance.new("TextButton")
    resetBtn.Size = UDim2.new(0.8, 0, 0, 30)
    resetBtn.Position = UDim2.new(0.1, 0, 0, 130)
    resetBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 80)
    resetBtn.Text = "Reset Used Words"
    resetBtn.TextColor3 = Color3.fromRGB(255,255,255)
    resetBtn.Parent = frame
    
    resetBtn.MouseButton1Click:Connect(function()
        usedWords = {}
        resetBtn.Text = "Cleared!"
        task.wait(1)
        resetBtn.Text = "Reset Used Words"
    end)
end

createUI()
