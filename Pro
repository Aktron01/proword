local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LogService = game:GetService("LogService")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- // ULTIMATE CONFIGURATION \\ --
local CONFIG = {
    Enabled = true,
    
    -- STRATEGY SETTINGS
    -- Modes: "Shortest", "Longest" (Troll), "Target" (Specific Ending), "Random"
    Strategy = "Shortest", 
    TargetEnding = "", 
    
    MinWordLength = 2,
    MaxWordLength = 35,
    
    -- HUMANIZATION SETTINGS
    HumanMode = true,        
    MaxTotalTime = 3.5,        
    MinTotalTime = 1.2,        
    
    ReactionMin = 0.8,      
    ReactionMax = 1.5,      
    
    MistakeChance = 0.05,        
    MicroPauseChance = 0.1,
    SubmitDelay = 0.1,        
}

-- // DICTIONARY SYSTEM \\ --
-- We structure this as { ["A"] = {"apple", ...}, ["B"] = ... } for O(1) access speed
local WORD_DATABASE = {} 
local usedWords = {}

-- Backup/Starter words to ensure it works immediately before HTTP loads
local STARTER_WORDS = {
    A = { "apple", "about", "after", "again", "alarm", "allow", "angry", "apart", "apple", "apply", "arena", "argue", "arise", "array", "aside", "asset", "audio", "audit", "avoid", "award", "aware" },
    B = { "basic", "beach", "begin", "black", "block", "board", "boost", "bound", "brain", "brake", "bread", "break", "brick", "brief", "bring", "broad", "brown", "brush", "build", "bunch", "burst" },
    -- (The loader will fill the rest, so we keep this small to save memory)
}
WORD_DATABASE = STARTER_WORDS

-- [Mega Dictionary Loader - Merged Feature]
local function loadExternalWordList()
    local urls = {
        "https://raw.githubusercontent.com/dwyl/english-words/refs/heads/master/words_dictionary.json",
        "https://raw.githubusercontent.com/first20hours/google-10000-english/master/google-10000-english-usa-no-swears.txt"
    }
    
    print(" [Ultimate Script] Loading Mega Dictionary...")
    
    local newDB = {}
    local count = 0
    
    for _, url in ipairs(urls) do
        local success, response = pcall(function() return game:HttpGet(url) end)
        if success and response then
            -- Handle JSON format
            if response:sub(1,1) == "{" then
                local decoded = HttpService:JSONDecode(response)
                for word, _ in pairs(decoded) do
                    if #word >= CONFIG.MinWordLength then
                        local first = word:sub(1, 1):upper()
                        if not newDB[first] then newDB[first] = {} end
                        table.insert(newDB[first], word)
                        count = count + 1
                    end
                end
            else
                -- Handle Text format
                for word in response:gmatch("%a+") do
                    if #word >= CONFIG.MinWordLength then
                        local first = word:sub(1, 1):upper()
                        if not newDB[first] then newDB[first] = {} end
                        table.insert(newDB[first], word)
                        count = count + 1
                    end
                end
            end
        end
    end
    
    -- Merge starter words
    for letter, list in pairs(STARTER_WORDS) do
        if not newDB[letter] then newDB[letter] = {} end
        for _, word in ipairs(list) do
            table.insert(newDB[letter], word)
        end
    end
    
    if count > 0 then
        WORD_DATABASE = newDB
        print(" [Ultimate Script] Successfully loaded " .. count .. " words!")
    else
        warn(" [Ultimate Script] Failed to load external words. Using backup.")
    end
end

task.spawn(loadExternalWordList)

-- // LOGIC FUNCTIONS \\ --

local function getValidWord(prefix)
    if not prefix or prefix == "" then return nil end
    local startLetter = prefix:sub(1, 1):upper()
    local words = WORD_DATABASE[startLetter]
    if not words then return nil end
    
    local validWords = {}
    local prefixLower = prefix:lower()
    local prefixLen = #prefix
    
    for _, word in ipairs(words) do
        -- Length Checks
        if #word >= CONFIG.MinWordLength and #word <= CONFIG.MaxWordLength then
            -- Prefix Match Check
            if word:sub(1, prefixLen):lower() == prefixLower then
                if not usedWords[word:lower()] then
                    table.insert(validWords, word:lower())
                end
            end
        end
    end
    
    -- Retry with used words if we ran out of new ones
    if #validWords == 0 then
        for _, word in ipairs(words) do
            if #word >= CONFIG.MinWordLength and #word <= CONFIG.MaxWordLength then
                if word:sub(1, prefixLen):lower() == prefixLower then
                    table.insert(validWords, word:lower())
                end
            end
        end
    end
    
    if #validWords == 0 then return nil end
    
    -- // STRATEGY SORTING ALGORITHM \\ --
    table.sort(validWords, function(a, b)
        -- Strategy 1: Target Ending (Aggressive)
        if CONFIG.Strategy == "Target" and CONFIG.TargetEnding ~= "" then
            local target = CONFIG.TargetEnding:lower()
            local aEnds = a:sub(-1) == target
            local bEnds = b:sub(-1) == target
            if aEnds and not bEnds then return true end
            if not aEnds and bEnds then return false end
        end
        
        -- Strategy 2: Longest (Troll Mode)
        if CONFIG.Strategy == "Longest" then
            return #a > #b
        end
        
        -- Strategy 3: Shortest (Speed Mode)
        if CONFIG.Strategy == "Shortest" then
            return #a < #b
        end
        
        -- Strategy 4: Random (Default/Fallback)
        return false -- Keep original order (random-ish) or handle via random pick
    end)
    
    local selectedWord
    if CONFIG.Strategy == "Random" then
        selectedWord = validWords[math.random(1, #validWords)]
    else
        -- Pick top result after sorting
        selectedWord = validWords[1]
    end
    
    usedWords[selectedWord] = true
    return selectedWord
end

-- // HUMANIZED TYPING \\ --

local function typeLetter(letter, holdDuration)
    local keyCode = Enum.KeyCode[string.upper(letter)]
    if keyCode then
        VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
        task.wait(holdDuration or 0.015)
        VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
    end
end

local function randomFloat(min, max)
    return min + math.random() * (max - min)
end

local function typeWord(word, reactionDelay)
    -- Calculate budget
    local targetTotalDuration = randomFloat(CONFIG.MinTotalTime, CONFIG.MaxTotalTime)
    
    -- Adjust for long words (Troll Mode support)
    if #word > 10 then 
        targetTotalDuration = targetTotalDuration + (#word * 0.05) 
    end

    if (reactionDelay + 0.5) > targetTotalDuration then
        targetTotalDuration = reactionDelay + 0.5 + (#word * 0.1)
    end
    
    local timeAvailableForTyping = targetTotalDuration - reactionDelay - CONFIG.SubmitDelay
    local avgDelayPerChar = timeAvailableForTyping / #word
    
    -- Cap speed to prevent instant-ban speeds
    if avgDelayPerChar < 0.03 then avgDelayPerChar = 0.03 end 
    
    for i = 1, #word do
        local letter = string.sub(word, i, i)
        local currentDelay = avgDelayPerChar * randomFloat(0.8, 1.2)
        
        -- Micro pauses for realism
        if math.random() < CONFIG.MicroPauseChance and i > 1 then
            currentDelay = currentDelay + randomFloat(0.1, 0.2)
        end
        
        -- Mistake simulation (Only in non-intense modes)
        if CONFIG.Strategy ~= "Longest" and math.random() < CONFIG.MistakeChance then
            -- Type wrong key
            local wrongKey = string.char(string.byte(letter) + 1)
            typeLetter(wrongKey, 0.02)
            task.wait(randomFloat(0.1, 0.2))
            -- Backspace
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Backspace, false, game)
            task.wait(0.05)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Backspace, false, game)
            task.wait(randomFloat(0.1, 0.2))
        end
        
        task.wait(currentDelay)
        typeLetter(letter, randomFloat(0.01, 0.05))
    end
end

local function submitWord()
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
    task.wait(0.02)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
end

-- // GAME STATE DETECTION (Dual Method: UI + Log) \\ --

local lastLogPattern = ""

-- [Merged Feature: Log Listener]
LogService.MessageOut:Connect(function(message, messageType)
    -- Pattern match for common game logs indicating required letters
    local pattern = "Word:%s*([A-Za-z]+)"
    local match = string.match(message, pattern)
    if match then
        lastLogPattern = match
    end
    
    -- Sometimes logs look like "Turn: PlayerName (AB)"
    local letters = string.match(message, "%((%u%u?)%)")
    if letters then
        lastLogPattern = letters
    end
end)

local function getRequiredLetterLabel()
    -- Method A: Read ScreenGui (Most Accurate)
    local success, result = pcall(function()
        local inGameUI = PlayerGui:FindFirstChild("InGame")
        if not inGameUI then return nil end
        local frame = inGameUI:FindFirstChild("Frame")
        if not frame then return nil end
        
        local typeLabel = frame:FindFirstChild("Type")
        if typeLabel and typeLabel:IsA("TextLabel") then
            local text = typeLabel.Text
            local letter = text:match("starting with:%s*(%a)")
            if letter then return letter:upper() end
            letter = text:match("can form a word with:%s*(%a)")
            if letter then return letter:upper() end
        end
        return nil
    end)
    
    if success and result then return result end
    return nil
end

local function getCurrentPrefix()
    -- Method A: Visual Boxes
    local success, result = pcall(function()
        local inGameUI = PlayerGui:FindFirstChild("InGame")
        if not inGameUI then return "" end
        local frame = inGameUI:FindFirstChild("Frame")
        if not frame then return "" end
        local currentWord = frame:FindFirstChild("CurrentWord")
        if not currentWord then return "" end
        
        local text = ""
        local index = 1
        while true do
            local charFrame = currentWord:FindFirstChild(tostring(index))
            if not charFrame then break end
            if charFrame:IsA("Frame") and charFrame.Visible then
                local letterLabel = charFrame:FindFirstChild("Letter")
                if letterLabel and letterLabel:IsA("TextLabel") then
                    text = text .. letterLabel.Text
                end
            end
            index = index + 1
        end
        return text
    end)
    
    if success and result and result ~= "" then return result end
    
    -- Method B: Fallback to LogService
    if lastLogPattern ~= "" then
        return lastLogPattern
    end
    
    return ""
end

local function isOurTurn()
    local success, result = pcall(function()
        local inGameUI = PlayerGui:FindFirstChild("InGame")
        if not inGameUI then return false end
        
        local frame = inGameUI:FindFirstChild("Frame")
        if not frame or not frame.Visible then return false end
        
        local circle = frame:FindFirstChild("Circle")
        if not circle or not circle.Visible then return false end
        
        local typeLabel = frame:FindFirstChild("Type")
        if typeLabel and typeLabel:IsA("TextLabel") then
            local text = typeLabel.Text
            local displayName = LocalPlayer.DisplayName
            local userName = LocalPlayer.Name
            if string.find(text, displayName) or string.find(text, userName) then
                return true
            end
        end
        return false
    end)
    return success and result or false
end

local function isInGame()
    local inTable = LocalPlayer:GetAttribute("InTable")
    return inTable == true
end

-- // MAIN LOOP \\ --
local isProcessing = false
local lastPlayTime = 0

local function autoPlay()
    if isProcessing then return end
    if not CONFIG.Enabled then return end
    if not isInGame() then return end
    if not isOurTurn() then return end
    
    local now = tick()
    if now - lastPlayTime < 1.0 then return end 
    
    isProcessing = true
    lastPlayTime = now
    
    -- 1. Identify letters
    local prefix = getCurrentPrefix()
    if prefix == "" then
        local req = getRequiredLetterLabel()
        if req then prefix = req end
    end
    
    if prefix == "" then
        isProcessing = false
        return
    end
    
    -- 2. Find Word using Strategy
    local fullWord = getValidWord(prefix)
    if not fullWord then
        isProcessing = false
        return
    end
    
    local suffix = fullWord:sub(#prefix + 1)
    
    -- 3. Reaction Delay
    local reactionTime = randomFloat(CONFIG.ReactionMin, CONFIG.ReactionMax)
    task.wait(reactionTime)
    
    -- 4. Type
    if suffix ~= "" then
        typeWord(suffix, reactionTime)
    end
    
    -- 5. Submit
    local finalDelay = CONFIG.SubmitDelay + randomFloat(0, 0.1)
    task.wait(finalDelay)
    submitWord()
    
    -- Clear log pattern to prevent stale data
    lastLogPattern = ""
    isProcessing = false
end

local function startMonitoring()
    task.spawn(function()
        while task.wait(0.1) do
            if CONFIG.Enabled then
                autoPlay()
            end
        end
    end)
    
    -- [Merged Feature: Auto Reset on Round Start]
    LocalPlayer:GetAttributeChangedSignal("InTable"):Connect(function()
        if LocalPlayer:GetAttribute("InTable") == true then
            usedWords = {} -- New round, fresh memory
        end
    end)
end

-- // ULTIMATE GUI CREATION \\ --
local function createUltimateUI()
    if PlayerGui:FindFirstChild("UltimateWordUI") then
        PlayerGui.UltimateWordUI:Destroy()
    end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "UltimateWordUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = PlayerGui
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 220, 0, 280)
    frame.Position = UDim2.new(0, 20, 0.5, -140)
    frame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    frame.BorderSizePixel = 0
    frame.Parent = screenGui
    
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 10)
    uiCorner.Parent = frame
    
    -- Title
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 30)
    title.BackgroundTransparency = 1
    title.Text = "Ultimate AutoPlay"
    title.TextColor3 = Color3.fromRGB(0, 255, 200)
    title.Font = Enum.Font.GothamBlack
    title.TextSize = 16
    title.Parent = frame
    
    -- [Toggle Button]
    local toggleBtn = Instance.new("TextButton")
    toggleBtn.Size = UDim2.new(0.9, 0, 0, 35)
    toggleBtn.Position = UDim2.new(0.05, 0, 0, 40)
    toggleBtn.BackgroundColor3 = CONFIG.Enabled and Color3.fromRGB(0, 180, 100) or Color3.fromRGB(180, 60, 60)
    toggleBtn.Text = CONFIG.Enabled and "STATUS: ACTIVE" or "STATUS: PAUSED"
    toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleBtn.Font = Enum.Font.GothamBold
    toggleBtn.TextSize = 14
    toggleBtn.Parent = frame
    local tCorner = Instance.new("UICorner"); tCorner.CornerRadius = UDim.new(0,6); tCorner.Parent = toggleBtn
    
    -- [Strategy Button (Merged Features)]
    local strategyBtn = Instance.new("TextButton")
    strategyBtn.Size = UDim2.new(0.9, 0, 0, 35)
    strategyBtn.Position = UDim2.new(0.05, 0, 0, 85)
    strategyBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 80)
    strategyBtn.Text = "MODE: " .. CONFIG.Strategy
    strategyBtn.TextColor3 = Color3.fromRGB(255, 220, 100)
    strategyBtn.Font = Enum.Font.GothamBold
    strategyBtn.TextSize = 13
    strategyBtn.Parent = frame
    local sCorner = Instance.new("UICorner"); sCorner.CornerRadius = UDim.new(0,6); sCorner.Parent = strategyBtn

    -- [Target Box]
    local targetLabel = Instance.new("TextLabel")
    targetLabel.Size = UDim2.new(1, 0, 0, 15)
    targetLabel.Position = UDim2.new(0, 0, 0, 125)
    targetLabel.Text = "Target Ending Letter:"
    targetLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    targetLabel.BackgroundTransparency = 1
    targetLabel.Font = Enum.Font.Gotham
    targetLabel.TextSize = 11
    targetLabel.Parent = frame

    local targetBox = Instance.new("TextBox")
    targetBox.Size = UDim2.new(0.9, 0, 0, 30)
    targetBox.Position = UDim2.new(0.05, 0, 0, 145)
    targetBox.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    targetBox.Text = ""
    targetBox.PlaceholderText = "e.g. 'x' (Select Target Mode)"
    targetBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    targetBox.Font = Enum.Font.Gotham
    targetBox.TextSize = 12
    targetBox.Parent = frame
    local tbCorner = Instance.new("UICorner"); tbCorner.CornerRadius = UDim.new(0,6); tbCorner.Parent = targetBox

    -- [Reset Memory Button (New)]
    local resetBtn = Instance.new("TextButton")
    resetBtn.Size = UDim2.new(0.9, 0, 0, 30)
    resetBtn.Position = UDim2.new(0.05, 0, 0, 185)
    resetBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 50)
    resetBtn.Text = "RESET MEMORY"
    resetBtn.TextColor3 = Color3.fromRGB(255, 200, 200)
    resetBtn.Font = Enum.Font.GothamBold
    resetBtn.TextSize = 12
    resetBtn.Parent = frame
    local rCorner = Instance.new("UICorner"); rCorner.CornerRadius = UDim.new(0,6); rCorner.Parent = resetBtn

    -- [Status Info]
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Size = UDim2.new(1, 0, 0, 20)
    statusLabel.Position = UDim2.new(0, 0, 0, 225)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Text = "Waiting for turn..."
    statusLabel.TextColor3 = Color3.fromRGB(120, 120, 120)
    statusLabel.Font = Enum.Font.Gotham
    statusLabel.TextSize = 11
    statusLabel.Parent = frame

    -- [Events]
    toggleBtn.MouseButton1Click:Connect(function()
        CONFIG.Enabled = not CONFIG.Enabled
        toggleBtn.BackgroundColor3 = CONFIG.Enabled and Color3.fromRGB(0, 180, 100) or Color3.fromRGB(180, 60, 60)
        toggleBtn.Text = CONFIG.Enabled and "STATUS: ACTIVE" or "STATUS: PAUSED"
    end)
    
    local strategies = {"Shortest", "Longest", "Target", "Random"}
    local sIndex = 1
    
    strategyBtn.MouseButton1Click:Connect(function()
        sIndex = sIndex + 1
        if sIndex > #strategies then sIndex = 1 end
        CONFIG.Strategy = strategies[sIndex]
        strategyBtn.Text = "MODE: " .. CONFIG.Strategy:upper()
        
        if CONFIG.Strategy == "Longest" then
             strategyBtn.TextColor3 = Color3.fromRGB(255, 100, 255) -- Troll Color
        elseif CONFIG.Strategy == "Target" then
             strategyBtn.TextColor3 = Color3.fromRGB(100, 200, 255)
        else
             strategyBtn.TextColor3 = Color3.fromRGB(255, 220, 100)
        end
    end)
    
    targetBox:GetPropertyChangedSignal("Text"):Connect(function()
        if #targetBox.Text > 1 then targetBox.Text = targetBox.Text:sub(1,1) end
        CONFIG.TargetEnding = targetBox.Text
    end)
    
    resetBtn.MouseButton1Click:Connect(function()
        usedWords = {}
        resetBtn.Text = "MEMORY CLEARED!"
        task.wait(1)
        resetBtn.Text = "RESET MEMORY"
    end)
    
    -- Status Updater
    task.spawn(function()
        while task.wait(0.5) do
            if not isInGame() then
                statusLabel.Text = "Not in round"
                statusLabel.TextColor3 = Color3.fromRGB(120,120,120)
            elseif isOurTurn() then
                statusLabel.Text = "YOUR TURN!"
                statusLabel.TextColor3 = Color3.fromRGB(0,255,0)
            else
                statusLabel.Text = "Waiting..."
                statusLabel.TextColor3 = Color3.fromRGB(200,200,200)
            end
        end
    end)
    
    -- Draggable Logic
    local dragging, dragInput, dragStart, startPos
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)
    frame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end

createUltimateUI()
startMonitoring()
