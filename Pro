local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TextChatService = game:GetService("TextChatService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- // ULTIMATE CONFIGURATION \\ --
local CONFIG = {
    Enabled = true,
    Strategy = "Shortest", 
    TargetEnding = "", 
    MinWordLength = 3, 
    MaxWordLength = 35,
    
    -- ROUND SETTINGS
    RoundDuration = 15,
    PanicThreshold = 4,   
    SafeModeThreshold = 6, 
    
    -- SPEED SETTINGS
    SpeedMultiplier = 1.0, 
    ReactionMin = 0.4,
    ReactionMax = 0.8,
    SubmitDelay = 0.05, 
    VerificationDelay = 0.8,
    
    -- Humanization
    HumanMode = true,
    MistakeChance = 0.08,        
    MicroPauseChance = 0.15,
}

-- // UI COLORS \\ --
local STRATEGY_COLORS = {
    Shortest = Color3.fromRGB(0, 255, 128),
    Longest = Color3.fromRGB(255, 60, 60),
    Target = Color3.fromRGB(170, 85, 255),
    Random = Color3.fromRGB(255, 200, 50)
}

-- // DICTIONARY SYSTEM \\ --
local STARTER_WORDS = {
    A={"apple","about"}, B={"basic","bread"}, C={"catch","clean"}, D={"dance","drive"},
    E={"early","entry"}, F={"faith","field"}, G={"game","great","group","guard","guess"},
    H={"happy","heart"}, I={"image","index"}, J={"joint","judge"}, K={"knife","knock"},
    L={"label","laugh"}, M={"magic","money"}, N={"never","night"}, O={"ocean","order"},
    P={"paper","phone"}, Q={"queen","quiet"}, R={"radio","range"}, S={"scale","sound"},
    T={"table","thing"}, U={"uncle","under"}, V={"value","voice"}, W={"water","world"},
    X={"xenon","xerox"}, Y={"year","young"}, Z={"zebra","zone"}
}

local WORD_DATABASE = STARTER_WORDS
local usedWords = {}

-- [Dictionary Loader]
task.spawn(function()
    local url = "https://raw.githubusercontent.com/Aktron01/word33/refs/heads/main/mainword.json"
    local success, response = pcall(function() return game:HttpGet(url) end)
    if not success or not response then return end

    local newDB = {}
    local count = 0
    for word in response:gmatch('"([%a]+)":') do
        if #word >= CONFIG.MinWordLength then
            local first = word:sub(1,1):upper()
            if not newDB[first] then newDB[first] = {} end
            table.insert(newDB[first], word)
            count = count + 1
        end
    end
    for letter, list in pairs(STARTER_WORDS) do
        if not newDB[letter] then newDB[letter] = {} end
        for _, word in ipairs(list) do table.insert(newDB[letter], word) end
    end
    if count > 0 then WORD_DATABASE = newDB end
end)

-- // GLOBAL STATE \\ --
local TurnStartTime = 0
local isProcessing = false 
local currentTurnBase = "" 

-- // LOGIC FUNCTIONS \\ --
local function randomFloat(min, max)
    return min + math.random() * (max - min)
end

local function sendToPublicChat(message)
    if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
        local channel = TextChatService.TextChannels:FindFirstChild("RBXGeneral")
        if channel then channel:SendAsync(message) return end
    end
    local legacyEvent = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
    if legacyEvent then
        local sayRequest = legacyEvent:FindFirstChild("SayMessageRequest")
        if sayRequest then sayRequest:FireServer(message, "All") return end
    end
end

local function typeLetter(letter)
    local keyCode = Enum.KeyCode[string.upper(letter)]
    if keyCode then
        VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
        VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
    end
end

local function typeWord(word)
    local len = #word
    
    -- [[ INSTANT TYPING FOR FAST MODE ]] --
    if CONFIG.RoundDuration == 5 then
        -- Absolutely NO delays between letters
        for i = 1, len do
            typeLetter(string.sub(word, i, i))
task.wait(0.2)
        end
        return
    end
    
    -- [[ NORMAL HUMAN TYPING ]] --
    local targetDuration = 0
    if len <= 4 then targetDuration = randomFloat(1.5, 2.5)
    elseif len <= 9 then targetDuration = randomFloat(3.0, 5.0)
    else targetDuration = randomFloat(4.5, 8.0) end
    
    targetDuration = targetDuration / CONFIG.SpeedMultiplier 
    local avgDelay = targetDuration / len
    
    for i = 1, len do
        local timeLeft = 10 
        if TurnStartTime > 0 then timeLeft = CONFIG.RoundDuration - (tick() - TurnStartTime) end
        
        local isPanic = timeLeft < CONFIG.PanicThreshold
        local letter = string.sub(word, i, i)
        typeLetter(letter)
        
        if isPanic then task.wait() 
        else
            local currentDelay = avgDelay * randomFloat(0.7, 1.3)
            if CONFIG.Strategy ~= "Longest" and math.random() < CONFIG.MicroPauseChance and i > 1 then
                currentDelay = currentDelay + randomFloat(0.15, 0.3)
            end
            task.wait(currentDelay)
        end
    end
end

local function submitWord()
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
    -- In Fast Mode (5s), we remove the small wait for Enter key
    if CONFIG.RoundDuration ~= 5 then task.wait(0.02) end
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
end

-- [[ SMART DELETION ]] --
-- This function deletes exactly N characters
local function smartDelete(amount)
    for i = 1, amount do
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Backspace, false, game)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Backspace, false, game)
        if CONFIG.RoundDuration ~= 5 then task.wait(0.02) end -- Tiny delay for human mode, instant for fast
    end
end

-- // SEARCH & GAME LOGIC \\ --
local function getMatchingWords(prefix)
    if not prefix or prefix == "" then return {} end
    local startLetter = prefix:sub(1, 1):upper()
    local words = WORD_DATABASE[startLetter]
    if not words then return {} end
    
    local matches = {}
    local prefixLower = prefix:lower()
    local prefixLen = #prefix
    local avoidTrapWords = (CONFIG.Strategy == "Target" and CONFIG.TargetEnding:lower() == "x")
    
    for _, word in ipairs(words) do
        if #word >= prefixLen and #word <= CONFIG.MaxWordLength then
            if word:sub(1, prefixLen):lower() == prefixLower then
                local wordLower = word:lower()
                local isSafe = true
                if avoidTrapWords then
                    local ending = wordLower:sub(-2)
                    if ending == "ax" or ending == "ex" or ending == "ox" then isSafe = false end
                end
                if isSafe and not usedWords[wordLower] then table.insert(matches, wordLower) end
            end
        end
    end
    return matches
end

local function getValidWord(prefix)
    local possibilities = getMatchingWords(prefix) 
    if #possibilities == 0 then return nil end
    
    local timeElapsed = tick() - TurnStartTime
    local timeLeft = CONFIG.RoundDuration - timeElapsed
    local forceShort = (timeLeft < CONFIG.SafeModeThreshold)
    
    table.sort(possibilities, function(a, b)
        if forceShort then return #a < #b end
        if CONFIG.Strategy == "Target" and CONFIG.TargetEnding ~= "" then
            local target = CONFIG.TargetEnding:lower()
            local aEnds = a:sub(-1) == target
            local bEnds = b:sub(-1) == target
            if aEnds and not bEnds then return true end
            if not aEnds and bEnds then return false end
        end
        if CONFIG.Strategy == "Longest" then return #a > #b end 
        if CONFIG.Strategy == "Shortest" then return #a < #b end
        return false 
    end)
    
    if CONFIG.Strategy == "Random" and not forceShort then
        return possibilities[math.random(1, #possibilities)]
    else
        return possibilities[1]
    end
end

local function getGameFrame()
    local success, frame = pcall(function() return PlayerGui.InGame.Frame end)
    return success and frame or nil
end

local function scanForUsedWords()
    local frame = getGameFrame()
    if not frame then return end
    pcall(function()
        for _, descendant in ipairs(frame:GetDescendants()) do
            if descendant:IsA("TextLabel") and descendant.Visible then
                local text = descendant.Text
                local cleanWord = text:match("^%s*([%a]+)%s*$")
                if cleanWord and #cleanWord >= CONFIG.MinWordLength then
                    usedWords[cleanWord:lower()] = true
                end
            end
        end
    end)
end

local function getRequiredLetterLabel()
    local frame = getGameFrame()
    if not frame then return nil end
    local typeLabel = frame:FindFirstChild("Type")
    if typeLabel and typeLabel:IsA("TextLabel") then
        local text = typeLabel.Text
        local letter = text:match("starting with:%s*(%a)")
        if letter then return letter:upper() end
        letter = text:match("can form a word with:%s*(%a)")
        if letter then return letter:upper() end
    end
    return nil
end

local function getCurrentPrefix()
    local frame = getGameFrame()
    if not frame then return "" end
    local currentWord = frame:FindFirstChild("CurrentWord")
    if not currentWord then return "" end
    local text = ""
    local index = 1
    while true do
        local charFrame = currentWord:FindFirstChild(tostring(index))
        if not charFrame then break end
        if charFrame:IsA("Frame") and charFrame.Visible then
            local letterLabel = charFrame:FindFirstChild("Letter")
            if letterLabel then text = text .. letterLabel.Text end
        end
        index = index + 1
    end
    return text
end

local function isOurTurn()
    local frame = getGameFrame()
    if not frame or not frame.Visible then return false end
    local circle = frame:FindFirstChild("Circle")
    if not circle or not circle.Visible then return false end
    local typeLabel = frame:FindFirstChild("Type")
    if typeLabel and typeLabel:IsA("TextLabel") then
        local text = typeLabel.Text
        if string.find(text, LocalPlayer.DisplayName) or string.find(text, LocalPlayer.Name) or string.find(text:lower(), "your turn") then
            return true
        end
    end
    return false
end

-- // COMPACT UI SYSTEM \\ --
local suggestionFrame
local updateSuggestions 

local function createUltimateUI()
    if PlayerGui:FindFirstChild("UltimateWordUI") then PlayerGui.UltimateWordUI:Destroy() end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "UltimateWordUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = PlayerGui
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 230) 
    frame.Position = UDim2.new(0, 10, 0.15, 0) 
    frame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    frame.BorderSizePixel = 0
    frame.Active = true
    frame.Draggable = true
    frame.Parent = screenGui
    Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 10)
    
    suggestionFrame = Instance.new("Frame")
    suggestionFrame.Size = UDim2.new(0, 200, 0, 230) 
    suggestionFrame.Position = UDim2.new(1, 5, 0, 0) 
    suggestionFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
    suggestionFrame.BorderSizePixel = 0
    suggestionFrame.Parent = frame
    Instance.new("UICorner", suggestionFrame).CornerRadius = UDim.new(0, 10)
    
    local listLayout = Instance.new("UIListLayout")
    listLayout.Parent = suggestionFrame
    listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    listLayout.Padding = UDim.new(0, 3)
    local padding = Instance.new("UIPadding"); padding.PaddingTop = UDim.new(0, 5); padding.Parent = suggestionFrame

    updateSuggestions = function(prefix)
        for _, child in pairs(suggestionFrame:GetChildren()) do
            if child:IsA("Frame") or child:IsA("TextButton") then child:Destroy() end 
        end
        local words = getMatchingWords(prefix)
        table.sort(words, function(a,b) return #a < #b end)
        
        local limit = 5
        for i = 1, math.min(#words, limit) do
            local word = words[i]
            local row = Instance.new("Frame")
            row.Size = UDim2.new(0.95, 0, 0, 35)
            row.BackgroundColor3 = Color3.fromRGB(40, 45, 60)
            row.Parent = suggestionFrame
            Instance.new("UICorner", row).CornerRadius = UDim.new(0,6)
            
            local wordLbl = Instance.new("TextLabel")
            wordLbl.Size = UDim2.new(0.4, 0, 1, 0); wordLbl.Position = UDim2.new(0,5,0,0); wordLbl.BackgroundTransparency = 1
            wordLbl.Text = word:upper(); wordLbl.TextColor3 = Color3.new(1,1,1); wordLbl.Font = Enum.Font.GothamBold; wordLbl.TextSize = 11; wordLbl.TextXAlignment = Enum.TextXAlignment.Left; wordLbl.Parent = row
            
            local playBtn = Instance.new("TextButton")
            playBtn.Size = UDim2.new(0.25, 0, 0.8, 0); playBtn.Position = UDim2.new(0.42,0,0.1,0); playBtn.BackgroundColor3 = Color3.fromRGB(0,180,100); playBtn.Text="PLAY"; playBtn.TextColor3=Color3.new(1,1,1); playBtn.Font=Enum.Font.GothamBold; playBtn.TextSize=9; playBtn.Parent=row; Instance.new("UICorner",playBtn).CornerRadius=UDim.new(0,4)
            
            local chatBtn = Instance.new("TextButton")
            chatBtn.Size = UDim2.new(0.25, 0, 0.8, 0); chatBtn.Position = UDim2.new(0.70,0,0.1,0); chatBtn.BackgroundColor3 = Color3.fromRGB(60,100,255); chatBtn.Text="CHAT"; chatBtn.TextColor3=Color3.new(1,1,1); chatBtn.Font=Enum.Font.GothamBold; chatBtn.TextSize=9; chatBtn.Parent=row; Instance.new("UICorner",chatBtn).CornerRadius=UDim.new(0,4)

            playBtn.MouseButton1Click:Connect(function()
                task.spawn(function()
                    usedWords[word:lower()] = true
                    local suffix = word:sub(#getCurrentPrefix() + 1)
                    if suffix ~= "" then typeWord(suffix) end
                    submitWord()
                end)
            end)

            chatBtn.MouseButton1Click:Connect(function()
                chatBtn.Text = "..."
                sendToPublicChat("Try: " .. word:upper())
                task.wait(0.5)
                chatBtn.Text = "SENT"
                task.wait(0.5)
                chatBtn.Text = "CHAT"
            end)
        end
    end

    local function makeBtn(name, text, color, posY, height)
        local b = Instance.new("TextButton")
        b.Name = name; b.Size = UDim2.new(0.9, 0, 0, height); b.Position = UDim2.new(0.05, 0, 0, posY)
        b.BackgroundColor3 = color; b.Text = text; b.TextColor3 = Color3.new(1,1,1)
        b.Font = Enum.Font.GothamBold; b.TextSize = 11
        b.Parent = frame
        Instance.new("UICorner", b).CornerRadius = UDim.new(0,6)
        return b
    end

    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 20); title.BackgroundTransparency = 1; title.Text = "AutoPlay Smart"; title.TextColor3 = Color3.fromRGB(0, 255, 200); title.Font = Enum.Font.GothamBlack; title.TextSize = 12; title.Parent = frame

    local toggleBtn = makeBtn("Toggle", "STATUS: ACTIVE", Color3.fromRGB(0, 180, 100), 25, 25)
    local strategyBtn = makeBtn("Strat", "MODE: SHORTEST", STRATEGY_COLORS.Shortest, 55, 25)
    
    local sliderBg = Instance.new("Frame"); sliderBg.Size = UDim2.new(0.9,0,0,25); sliderBg.Position = UDim2.new(0.05,0,0,85); sliderBg.BackgroundColor3=Color3.fromRGB(40,40,50); sliderBg.Parent=frame; Instance.new("UICorner",sliderBg).CornerRadius=UDim.new(0,6)
    local sliderFill = Instance.new("Frame"); sliderFill.Size = UDim2.new(0.2,0,1,0); sliderFill.BackgroundColor3=Color3.fromRGB(0,200,255); sliderFill.Parent=sliderBg; Instance.new("UICorner",sliderFill).CornerRadius=UDim.new(0,6)
    local sliderTxt = Instance.new("TextLabel"); sliderTxt.Size=UDim2.new(1,0,1,0); sliderTxt.BackgroundTransparency=1; sliderTxt.Text="Speed: 1.0x"; sliderTxt.TextColor3=Color3.new(1,1,1); sliderTxt.Font=Enum.Font.GothamBold; sliderTxt.TextSize=11; sliderTxt.Parent=sliderBg
    local sliderBtn = Instance.new("TextButton"); sliderBtn.Size=UDim2.new(1,0,1,0); sliderBtn.BackgroundTransparency=1; sliderBtn.Text=""; sliderBtn.Parent=sliderBg

    local targetBox = Instance.new("TextBox")
    targetBox.Size = UDim2.new(0.9, 0, 0, 25); targetBox.Position = UDim2.new(0.05, 0, 0, 115); targetBox.BackgroundColor3 = Color3.fromRGB(40,40,50); targetBox.Text = ""; targetBox.PlaceholderText = "Target Letter"; targetBox.TextColor3 = Color3.new(1,1,1); targetBox.Font = Enum.Font.Gotham; targetBox.TextSize = 11; targetBox.Parent = frame; Instance.new("UICorner",targetBox).CornerRadius = UDim.new(0,6)

    local timerBtn = makeBtn("Timer", "TIMER: NORMAL (15s)", Color3.fromRGB(0, 150, 255), 145, 25)
    local resetBtn = makeBtn("Reset", "RESET WORDS", Color3.fromRGB(80, 50, 50), 175, 25)
    
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Size = UDim2.new(1, 0, 0, 15); statusLabel.Position = UDim2.new(0, 0, 0, 205); statusLabel.BackgroundTransparency = 1; statusLabel.Text = "Waiting..."; statusLabel.TextColor3 = Color3.fromRGB(150, 150, 150); statusLabel.Font = Enum.Font.Gotham; statusLabel.TextSize = 10; statusLabel.Parent = frame

    toggleBtn.MouseButton1Click:Connect(function()
        CONFIG.Enabled = not CONFIG.Enabled
        toggleBtn.BackgroundColor3 = CONFIG.Enabled and Color3.fromRGB(0, 180, 100) or Color3.fromRGB(180, 60, 60)
        toggleBtn.Text = CONFIG.Enabled and "STATUS: ACTIVE" or "STATUS: PAUSED"
    end)

    local strategies = {"Shortest", "Longest", "Target", "Random"}
    local sIndex = 1
    strategyBtn.MouseButton1Click:Connect(function()
        sIndex = sIndex + 1; if sIndex > #strategies then sIndex = 1 end
        CONFIG.Strategy = strategies[sIndex]
        strategyBtn.Text = "MODE: " .. CONFIG.Strategy:upper()
        if STRATEGY_COLORS[CONFIG.Strategy] then strategyBtn.BackgroundColor3 = STRATEGY_COLORS[CONFIG.Strategy] end
    end)
    
    targetBox:GetPropertyChangedSignal("Text"):Connect(function()
        if #targetBox.Text > 1 then targetBox.Text = targetBox.Text:sub(1,1) end
        CONFIG.TargetEnding = targetBox.Text
    end)

    local dragging = false
    sliderBtn.MouseButton1Down:Connect(function() dragging = true end)
    UserInputService.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local relativePos = math.clamp((UserInputService:GetMouseLocation().X - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X, 0, 1)
            sliderFill.Size = UDim2.new(relativePos, 0, 1, 0)
            CONFIG.SpeedMultiplier = math.floor((0.5 + (relativePos * 4.5)) * 10) / 10
            sliderTxt.Text = "Speed: " .. CONFIG.SpeedMultiplier .. "x"
        end
    end)

    local isShortMode = false
    timerBtn.MouseButton1Click:Connect(function()
        isShortMode = not isShortMode
        if isShortMode then
            CONFIG.RoundDuration = 5
            CONFIG.ReactionMin = 0.5; CONFIG.ReactionMax = 0.5 
            CONFIG.SubmitDelay = 0
            timerBtn.Text = "TIMER: FAST (0.5s Delay)"
            timerBtn.BackgroundColor3 = Color3.fromRGB(255, 140, 0)
        else
            CONFIG.RoundDuration = 15
            CONFIG.ReactionMin = 0.4; CONFIG.ReactionMax = 0.8
            CONFIG.SubmitDelay = 0.05
            timerBtn.Text = "TIMER: NORMAL (15s)"
            timerBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
        end
    end)

    resetBtn.MouseButton1Click:Connect(function() usedWords = {}; resetBtn.Text = "CLEARED!"; task.wait(1); resetBtn.Text = "RESET WORDS" end)
    
    task.spawn(function()
        while task.wait(0.2) do
            if screenGui.Parent and isOurTurn() then
                local timeLeft = CONFIG.RoundDuration - (tick() - TurnStartTime)
                statusLabel.Text = "YOUR TURN: " .. math.floor(timeLeft) .. "s"
                statusLabel.TextColor3 = (timeLeft < CONFIG.PanicThreshold) and Color3.fromRGB(255, 50, 50) or Color3.fromRGB(0, 255, 0)
            else
                statusLabel.Text = "Scanning..."
                statusLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
            end
        end
    end)
    
    UserInputService.InputBegan:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.RightShift or input.KeyCode == Enum.KeyCode.LeftShift then 
            frame.Visible = not frame.Visible 
        end
    end)
end

-- // MAIN LOOPS \\ --
local lastTurnState = false
local lastKnownPrefix = ""

task.spawn(function()
    while task.wait(0.1) do
        local myTurn = isOurTurn()
        local prefix = getCurrentPrefix()
        if myTurn and not lastTurnState then
            TurnStartTime = tick(); task.wait(0.05)
            if prefix == "" then 
                local req = getRequiredLetterLabel()
                if req then prefix = req end
            end
            currentTurnBase = prefix
        end
        if prefix == "" and currentTurnBase ~= "" and myTurn then prefix = currentTurnBase end
        if prefix ~= lastKnownPrefix or myTurn ~= lastTurnState then
            if updateSuggestions then updateSuggestions(prefix) end
            lastKnownPrefix = prefix
        end
        lastTurnState = myTurn
        scanForUsedWords()
    end
end)

task.spawn(function()
    while task.wait() do
        if CONFIG.Enabled and isOurTurn() and not isProcessing then
            isProcessing = true
            local prefix = getCurrentPrefix()
            if prefix == "" then prefix = currentTurnBase end
            
            if prefix ~= "" then
                local fullWord = getValidWord(prefix)
                if fullWord then
                    -- 1. Reaction Delay (Thinking Time)
                    if CONFIG.RoundDuration ~= 5 then 
                        task.wait(randomFloat(CONFIG.ReactionMin, CONFIG.ReactionMax))
                    else
                        task.wait(0.5) -- Forced 0.5s start delay for fast mode
                    end
                    
                    if isOurTurn() then
                        -- 2. Type and Submit
                        local suffix = fullWord:sub(#prefix + 1)
                        local lettersTyped = #suffix -- Remember how many letters we typed
                        
                        if suffix ~= "" then typeWord(suffix) end
                        submitWord()
                        
                        -- Mark used immediately
                        usedWords[fullWord:lower()] = true
                        
                        -- 3. FAIL SAFE (Smart Delete)
                        if CONFIG.RoundDuration == 5 then
                            task.wait(0.1) 
                            if isOurTurn() then
                                -- If it is STILL our turn, the word failed.
                                -- Delete exactly what we typed.
                                smartDelete(lettersTyped)
                            end
                        else
                            task.wait(CONFIG.VerificationDelay)
                        end
                    end
                end
            end
            isProcessing = false
        end
    end
end)

createUltimateUI()
print(" [Ultimate] Fixed: Smart Backspace & Instant Fast Mode.")
