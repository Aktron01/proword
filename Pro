local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LogService = game:GetService("LogService")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- // ULTIMATE CONFIGURATION \\ --
local CONFIG = {
    Enabled = true,
    
    -- GAME MODE SETTINGS
    -- "Normal" = Types the whole word
    -- "OneByOne" = Types only the next letter
    GameMode = "Normal", 

    -- STRATEGY SETTINGS
    Strategy = "Shortest", 
    TargetEnding = "", 
    
    MinWordLength = 4,
    MaxWordLength = 35,
    
    -- ROUND SETTINGS
    RoundDuration = 15,
    PanicThreshold = 5,    
    SafeModeThreshold = 8,
    
    -- HUMANIZATION SETTINGS
    HumanMode = true,        
    SpeedMultiplier = 1.0, 
    
    -- REACTION DELAY (Seconds)
    ReactionMin = 1.0,
    ReactionMax = 1.5,
    
    MistakeChance = 0.08,        
    MicroPauseChance = 0.15,
    SubmitDelay = 0.05, 
    
    VerificationDelay = 0.8,
}

-- // DICTIONARY SYSTEM \\ --
local STARTER_WORDS = {
    A={"apple","about"}, B={"basic","bread"}, C={"catch","clean"}, D={"dance","drive"},
    E={"early","entry"}, F={"faith","field"}, G={"game","great","group","guard","guess"},
    H={"happy","heart"}, I={"image","index"}, J={"joint","judge"}, K={"knife","knock"},
    L={"label","laugh"}, M={"magic","money"}, N={"never","night"}, O={"ocean","order"},
    P={"paper","phone"}, Q={"queen","quiet"}, R={"radio","range"}, S={"scale","sound"},
    T={"table","thing"}, U={"uncle","under"}, V={"value","voice"}, W={"water","world"},
    X={"xenon","xerox"}, Y={"year","young"}, Z={"zebra","zone"}
}

local WORD_DATABASE = STARTER_WORDS
local usedWords = {}

-- [Dictionary Loader]
task.spawn(function()
    local url = "https://raw.githubusercontent.com/Aktron01/jsonwords/refs/heads/main/mainword.json"
    local success, response = pcall(function() return game:HttpGet(url) end)
    
    if not success or not response then 
        warn(" [Ultimate] Download failed. Using starter words.")
        return 
    end

    local newDB = {}
    local count = 0
    
    for word in response:gmatch('"([%a]+)":') do
        if #word >= CONFIG.MinWordLength then
            local first = word:sub(1,1):upper()
            if not newDB[first] then newDB[first] = {} end
            table.insert(newDB[first], word)
            count = count + 1
        end
    end
    
    for letter, list in pairs(STARTER_WORDS) do
        if not newDB[letter] then newDB[letter] = {} end
        for _, word in ipairs(list) do
            table.insert(newDB[letter], word)
        end
    end
    
    if count > 0 then
        WORD_DATABASE = newDB
        print(" [Ultimate] Loaded " .. count .. " words.")
    end
end)

-- // GLOBAL STATE \\ --
local TurnStartTime = 0
local isProcessing = false 
local lastProcessTime = 0 
local currentTurnBase = "" 

-- // LOGIC FUNCTIONS \\ --

local function getValidWord(prefix)
    if not prefix or prefix == "" then return nil end
    local startLetter = prefix:sub(1, 1):upper()
    local words = WORD_DATABASE[startLetter]
    
    if not words then return nil end
    
    local validWords = {}
    local prefixLower = prefix:lower()
    local prefixLen = #prefix
    
    local avoidTrapWords = (CONFIG.Strategy == "Target" and CONFIG.TargetEnding:lower() == "x")

    for _, word in ipairs(words) do
        if #word >= prefixLen and #word <= CONFIG.MaxWordLength then
            if word:sub(1, prefixLen):lower() == prefixLower then
                local wordLower = word:lower()
                
                local isSafe = true
                if avoidTrapWords then
                    local ending = wordLower:sub(-2)
                    if ending == "ax" or ending == "ex" or ending == "ox" then
                        isSafe = false
                    end
                end

                if isSafe and not usedWords[wordLower] then
                    table.insert(validWords, wordLower)
                end
            end
        end
    end
    
    if #validWords == 0 then
        for _, word in ipairs(words) do
            if #word >= prefixLen and #word <= CONFIG.MaxWordLength then
                if word:sub(1, prefixLen):lower() == prefixLower then
                    if not usedWords[word:lower()] then
                        table.insert(validWords, word:lower())
                    end
                end
            end
        end
    end
    
    if #validWords == 0 then return nil end
    
    local timeElapsed = tick() - TurnStartTime
    local timeLeft = CONFIG.RoundDuration - timeElapsed
    local forceShort = false
    
    if timeLeft < CONFIG.SafeModeThreshold then
        forceShort = true
    end
    
    table.sort(validWords, function(a, b)
        if forceShort then return #a < #b end
        
        if CONFIG.Strategy == "Target" and CONFIG.TargetEnding ~= "" then
            local target = CONFIG.TargetEnding:lower()
            local aEnds = a:sub(-1) == target
            local bEnds = b:sub(-1) == target
            if aEnds and not bEnds then return true end
            if not aEnds and bEnds then return false end
        end
        
        if CONFIG.Strategy == "Longest" then return #a > #b end
        if CONFIG.Strategy == "Shortest" then return #a < #b end
        
        return false 
    end)
    
    local selectedWord
    if CONFIG.Strategy == "Random" and not forceShort then
        selectedWord = validWords[math.random(1, #validWords)]
    else
        selectedWord = validWords[1]
    end
    
    return selectedWord
end

local function randomFloat(min, max)
    return min + math.random() * (max - min)
end

local function typeLetter(letter, fastMode)
    local keyCode = Enum.KeyCode[string.upper(letter)]
    if keyCode then
        VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
        if not fastMode then
            task.wait(randomFloat(0.015, 0.035)) 
        end
        VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
    end
end

local function clearText(count)
    local loopCount = count or 1
    if loopCount < 1 then return end
    
    for i = 1, loopCount do 
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Backspace, false, game)
        task.wait() 
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Backspace, false, game)
    end
end

local function typeWord(word)
    local len = #word
    local targetDuration = 0
    
    if len <= 4 then targetDuration = randomFloat(1.5, 2.5)
    elseif len <= 9 then targetDuration = randomFloat(3.0, 5.0)
    else targetDuration = randomFloat(5.0, 10.0) end
    
    targetDuration = targetDuration / CONFIG.SpeedMultiplier 
    local avgDelay = targetDuration / len
    
    for i = 1, len do
        local timeLeft = CONFIG.RoundDuration - (tick() - TurnStartTime)
        local isPanic = timeLeft < CONFIG.PanicThreshold
        
        local letter = string.sub(word, i, i)
        
        if isPanic then
            typeLetter(letter, true)
            task.wait() 
        else
            local currentDelay = avgDelay * randomFloat(0.7, 1.3)
            
            if CONFIG.Strategy ~= "Longest" and math.random() < CONFIG.MicroPauseChance and i > 1 then
                currentDelay = currentDelay + randomFloat(0.15, 0.3)
            end
            
            local adjustedMistakeChance = CONFIG.MistakeChance
            if CONFIG.SpeedMultiplier > 1.5 then adjustedMistakeChance = 0.02 end
            
            if math.random() < adjustedMistakeChance then
                 local wrongKey = string.char(string.byte(letter) + 1)
                 typeLetter(wrongKey, false)
                 task.wait(randomFloat(0.1, 0.2))
                 VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Backspace, false, game)
                 task.wait(randomFloat(0.05, 0.1))
                 VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Backspace, false, game)
                 task.wait(randomFloat(0.1, 0.2))
            end
            
            task.wait(currentDelay)
            typeLetter(letter, false)
        end
    end
end

local function submitWord()
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
    task.wait(0.02)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
end

-- // GAME STATE DETECTION \\ --

local function getGameFrame()
    local success, frame = pcall(function()
        return PlayerGui.InGame.Frame
    end)
    return success and frame or nil
end

local function scanForUsedWords()
    local frame = getGameFrame()
    if not frame then return end
    
    pcall(function()
        for _, descendant in ipairs(frame:GetDescendants()) do
            if descendant:IsA("TextLabel") and descendant.Visible then
                local text = descendant.Text
                local cleanWord = text:match("^%s*([%a]+)%s*$")
                
                if cleanWord and #cleanWord >= CONFIG.MinWordLength then
                    cleanWord = cleanWord:lower()
                    local firstLetter = cleanWord:sub(1,1):upper()
                    local dictionaryList = WORD_DATABASE[firstLetter]
                    
                    if dictionaryList then
                        if not usedWords[cleanWord] then
                             for _, w in ipairs(dictionaryList) do
                                if w:lower() == cleanWord then
                                    usedWords[cleanWord] = true
                                    break
                                end
                             end
                        end
                    end
                end
            end
        end
    end)
end

local function getRequiredLetterLabel()
    local frame = getGameFrame()
    if not frame then return nil end
    local typeLabel = frame:FindFirstChild("Type")
    if typeLabel and typeLabel:IsA("TextLabel") then
        local text = typeLabel.Text
        local letter = text:match("starting with:%s*(%a)")
        if letter then return letter:upper() end
        letter = text:match("can form a word with:%s*(%a)")
        if letter then return letter:upper() end
    end
    return nil
end

local function getCurrentPrefix()
    local frame = getGameFrame()
    if not frame then return "" end
    local currentWord = frame:FindFirstChild("CurrentWord")
    if not currentWord then return "" end
    
    local text = ""
    local index = 1
    while true do
        local charFrame = currentWord:FindFirstChild(tostring(index))
        if not charFrame then break end
        if charFrame:IsA("Frame") and charFrame.Visible then
            local letterLabel = charFrame:FindFirstChild("Letter")
            if letterLabel then text = text .. letterLabel.Text end
        end
        index = index + 1
    end
    return text
end

local function isOurTurn()
    local frame = getGameFrame()
    if not frame or not frame.Visible then return false end
    
    local circle = frame:FindFirstChild("Circle")
    if not circle or not circle.Visible then return false end
    
    local typeLabel = frame:FindFirstChild("Type")
    if typeLabel and typeLabel:IsA("TextLabel") then
        local text = typeLabel.Text
        if string.find(text, LocalPlayer.DisplayName) or 
           string.find(text, LocalPlayer.Name) or 
           string.find(text:lower(), "your turn") then
            return true
        end
    end
    return false
end

-- // MAIN LOOP \\ --
local lastTurnState = false

local function autoPlay()
    if isProcessing then 
        if tick() - lastProcessTime > 5 then
             isProcessing = false
        end
        return 
    end
    
    if not CONFIG.Enabled then return end
    
    scanForUsedWords()
    
    local myTurn = isOurTurn()
    if myTurn and not lastTurnState then
        TurnStartTime = tick()
        task.wait(0.1) 
        currentTurnBase = getCurrentPrefix()
        if currentTurnBase == "" then 
            local req = getRequiredLetterLabel()
            if req then currentTurnBase = req end
        end
    end
    lastTurnState = myTurn
    
    if not myTurn then return end
    
    isProcessing = true
    lastProcessTime = tick() 
    
    for attempt = 1, 4 do 
        if not isOurTurn() then break end 
        
        local prefix = getCurrentPrefix()
        if prefix == "" then prefix = currentTurnBase end
        
        if prefix == "" then 
            task.wait(0.2)
        else
            local fullWord = getValidWord(prefix)
            
            if not fullWord then 
                if #prefix > #currentTurnBase then
                     local charsToDelete = #prefix - #currentTurnBase
                     if charsToDelete > 10 then charsToDelete = 10 end
                     clearText(charsToDelete)
                     task.wait(0.3)
                else
                     task.wait(0.5)
                end
            else
                local suffix = fullWord:sub(#prefix + 1)
                
                if suffix ~= "" then
                    -- [DELAY LOGIC]
                    local timeLeft = CONFIG.RoundDuration - (tick() - TurnStartTime)
                    if attempt == 1 and timeLeft > CONFIG.PanicThreshold then
                        local thinkTime = randomFloat(CONFIG.ReactionMin, CONFIG.ReactionMax)
                        task.wait(thinkTime)
                        if not isOurTurn() then break end
                    end
                    
                    -- [ONE BY ONE MODE LOGIC]
                    if CONFIG.GameMode == "OneByOne" then
                        -- Only type the very first letter of the suffix
                        local nextChar = suffix:sub(1, 1)
                        typeLetter(nextChar, false)
                    else
                        -- Type the whole word normally
                        typeWord(suffix)
                    end
                end
                
                task.wait(CONFIG.SubmitDelay)
                submitWord()
                
                local checkTime = CONFIG.VerificationDelay
                if attempt > 1 then checkTime = 0.4 end
                
                task.wait(checkTime)
                
                if not isOurTurn() then
                    usedWords[fullWord:lower()] = true
                    break
                else
                    -- If it's still our turn after submitting, something happened
                    if CONFIG.GameMode == "Normal" then
                        -- In normal mode, mark word as used so we try a different one
                        usedWords[fullWord:lower()] = true
                        if suffix ~= "" then
                            clearText(#suffix)
                            task.wait(0.2)
                        end
                    else
                        -- In OneByOne, we might still be in the turn if animation is slow
                        -- or if we just typed one letter. We loop again to re-read prefix.
                        task.wait(0.1)
                    end
                end
            end
        end
    end
    
    isProcessing = false
end

local function startMonitoring()
    task.spawn(function()
        while task.wait(0.1) do
            if CONFIG.Enabled then
                local success, err = pcall(autoPlay)
                if not success then
                    warn("AutoPlay Error:", err)
                    isProcessing = false
                end
            end
        end
    end)
end

-- // ULTIMATE GUI CREATION \\ --
local function createUltimateUI()
    if PlayerGui:FindFirstChild("UltimateWordUI") then
        PlayerGui.UltimateWordUI:Destroy()
    end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "UltimateWordUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = PlayerGui
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 220, 0, 350) -- Increased height
    frame.Position = UDim2.new(0, 20, 0.5, -175)
    frame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    frame.BorderSizePixel = 0
    frame.Active = true
    frame.Draggable = true
    frame.Parent = screenGui
    
    local uiCorner = Instance.new("UICorner"); uiCorner.CornerRadius = UDim.new(0, 10); uiCorner.Parent = frame
    
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 30)
    title.BackgroundTransparency = 1
    title.Text = "AutoPlay v11 (Multi-Mode)"
    title.TextColor3 = Color3.fromRGB(0, 255, 200)
    title.Font = Enum.Font.GothamBlack
    title.TextSize = 13
    title.Parent = frame
    
    -- [Toggle]
    local toggleBtn = Instance.new("TextButton")
    toggleBtn.Size = UDim2.new(0.9, 0, 0, 35)
    toggleBtn.Position = UDim2.new(0.05, 0, 0, 40)
    toggleBtn.BackgroundColor3 = CONFIG.Enabled and Color3.fromRGB(0, 180, 100) or Color3.fromRGB(180, 60, 60)
    toggleBtn.Text = CONFIG.Enabled and "STATUS: ACTIVE" or "STATUS: PAUSED"
    toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleBtn.Font = Enum.Font.GothamBold
    toggleBtn.TextSize = 14
    toggleBtn.Parent = frame
    local tCorner = Instance.new("UICorner"); tCorner.CornerRadius = UDim.new(0,6); tCorner.Parent = toggleBtn
    
    -- [Game Mode Button]
    local modeBtn = Instance.new("TextButton")
    modeBtn.Size = UDim2.new(0.9, 0, 0, 30)
    modeBtn.Position = UDim2.new(0.05, 0, 0, 85)
    modeBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 70)
    modeBtn.Text = "TYPE: " .. (CONFIG.GameMode == "Normal" and "FULL WORD" or "1-BY-1")
    modeBtn.TextColor3 = Color3.fromRGB(200, 200, 255)
    modeBtn.Font = Enum.Font.GothamBold
    modeBtn.TextSize = 13
    modeBtn.Parent = frame
    local mCorner = Instance.new("UICorner"); mCorner.CornerRadius = UDim.new(0,6); mCorner.Parent = modeBtn

    -- [Strategy]
    local strategyBtn = Instance.new("TextButton")
    strategyBtn.Size = UDim2.new(0.9, 0, 0, 30)
    strategyBtn.Position = UDim2.new(0.05, 0, 0, 120)
    strategyBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 80)
    strategyBtn.Text = "STRAT: " .. CONFIG.Strategy:upper()
    strategyBtn.TextColor3 = Color3.fromRGB(255, 220, 100)
    strategyBtn.Font = Enum.Font.GothamBold
    strategyBtn.TextSize = 13
    strategyBtn.Parent = frame
    local sCorner = Instance.new("UICorner"); sCorner.CornerRadius = UDim.new(0,6); sCorner.Parent = strategyBtn

    -- [SLIDER]
    local sliderLabel = Instance.new("TextLabel")
    sliderLabel.Size = UDim2.new(1, 0, 0, 15)
    sliderLabel.Position = UDim2.new(0, 0, 0, 160)
    sliderLabel.Text = "Typing Speed: 1.0x"
    sliderLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    sliderLabel.BackgroundTransparency = 1
    sliderLabel.Font = Enum.Font.GothamBold
    sliderLabel.TextSize = 11
    sliderLabel.Parent = frame
    
    local sliderBg = Instance.new("Frame")
    sliderBg.Size = UDim2.new(0.9, 0, 0, 8)
    sliderBg.Position = UDim2.new(0.05, 0, 0, 180)
    sliderBg.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    sliderBg.Parent = frame
    local slCorner = Instance.new("UICorner"); slCorner.CornerRadius = UDim.new(1,0); slCorner.Parent = sliderBg
    
    local sliderFill = Instance.new("Frame")
    sliderFill.Size = UDim2.new(0.2, 0, 1, 0)
    sliderFill.BackgroundColor3 = Color3.fromRGB(0, 200, 255)
    sliderFill.Parent = sliderBg
    local sfCorner = Instance.new("UICorner"); sfCorner.CornerRadius = UDim.new(1,0); sfCorner.Parent = sliderFill
    
    local sliderBtn = Instance.new("TextButton")
    sliderBtn.Size = UDim2.new(1, 0, 1, 0)
    sliderBtn.BackgroundTransparency = 1
    sliderBtn.Text = ""
    sliderBtn.Parent = sliderBg
    
    local dragging = false
    local minSpeed = 0.5
    local maxSpeed = 5.0
    
    sliderBtn.MouseButton1Down:Connect(function() dragging = true end)
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local mousePos = UserInputService:GetMouseLocation().X
            local framePos = sliderBg.AbsolutePosition.X
            local frameSize = sliderBg.AbsoluteSize.X
            local relativePos = math.clamp((mousePos - framePos) / frameSize, 0, 1)
            
            sliderFill.Size = UDim2.new(relativePos, 0, 1, 0)
            
            local newSpeed = minSpeed + (relativePos * (maxSpeed - minSpeed))
            newSpeed = math.floor(newSpeed * 10) / 10 
            
            CONFIG.SpeedMultiplier = newSpeed
            sliderLabel.Text = "Typing Speed: " .. newSpeed .. "x"
            
            if newSpeed > 3 then
                sliderFill.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
                sliderLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
            else
                sliderFill.BackgroundColor3 = Color3.fromRGB(0, 200, 255)
                sliderLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
            end
        end
    end)

    -- [Target Box] 
    local targetLabel = Instance.new("TextLabel")
    targetLabel.Size = UDim2.new(1, 0, 0, 15)
    targetLabel.Position = UDim2.new(0, 0, 0, 200)
    targetLabel.Text = "Target Ending Letter:"
    targetLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    targetLabel.BackgroundTransparency = 1
    targetLabel.Font = Enum.Font.Gotham
    targetLabel.TextSize = 11
    targetLabel.Parent = frame

    local targetBox = Instance.new("TextBox")
    targetBox.Size = UDim2.new(0.9, 0, 0, 30)
    targetBox.Position = UDim2.new(0.05, 0, 0, 220)
    targetBox.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    targetBox.Text = ""
    targetBox.PlaceholderText = "e.g. 'x'"
    targetBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    targetBox.Font = Enum.Font.Gotham
    targetBox.TextSize = 12
    targetBox.Parent = frame
    local tbCorner = Instance.new("UICorner"); tbCorner.CornerRadius = UDim.new(0,6); tbCorner.Parent = targetBox

    -- [Reset Memory] 
    local resetBtn = Instance.new("TextButton")
    resetBtn.Size = UDim2.new(0.9, 0, 0, 30)
    resetBtn.Position = UDim2.new(0.05, 0, 0, 260)
    resetBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 50)
    resetBtn.Text = "RESET MEMORY"
    resetBtn.TextColor3 = Color3.fromRGB(255, 200, 200)
    resetBtn.Font = Enum.Font.GothamBold
    resetBtn.TextSize = 12
    resetBtn.Parent = frame
    local rCorner = Instance.new("UICorner"); rCorner.CornerRadius = UDim.new(0,6); rCorner.Parent = resetBtn

    -- [Status Info] 
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Size = UDim2.new(1, 0, 0, 20)
    statusLabel.Position = UDim2.new(0, 0, 0, 310)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Text = "Waiting..."
    statusLabel.TextColor3 = Color3.fromRGB(120, 120, 120)
    statusLabel.Font = Enum.Font.Gotham
    statusLabel.TextSize = 11
    statusLabel.Parent = frame

    -- Events
    toggleBtn.MouseButton1Click:Connect(function()
        CONFIG.Enabled = not CONFIG.Enabled
        toggleBtn.BackgroundColor3 = CONFIG.Enabled and Color3.fromRGB(0, 180, 100) or Color3.fromRGB(180, 60, 60)
        toggleBtn.Text = CONFIG.Enabled and "STATUS: ACTIVE" or "STATUS: PAUSED"
    end)
    
    modeBtn.MouseButton1Click:Connect(function()
        if CONFIG.GameMode == "Normal" then
            CONFIG.GameMode = "OneByOne"
            modeBtn.Text = "TYPE: 1-BY-1"
            modeBtn.TextColor3 = Color3.fromRGB(255, 180, 100)
        else
            CONFIG.GameMode = "Normal"
            modeBtn.Text = "TYPE: FULL WORD"
            modeBtn.TextColor3 = Color3.fromRGB(200, 200, 255)
        end
    end)
    
    local strategies = {"Shortest", "Longest", "Target", "Random"}
    local sIndex = 1
    
    strategyBtn.MouseButton1Click:Connect(function()
        sIndex = sIndex + 1
        if sIndex > #strategies then sIndex = 1 end
        CONFIG.Strategy = strategies[sIndex]
        strategyBtn.Text = "STRAT: " .. CONFIG.Strategy:upper()
        
        if CONFIG.Strategy == "Longest" then
             strategyBtn.TextColor3 = Color3.fromRGB(255, 100, 255)
        elseif CONFIG.Strategy == "Target" then
             strategyBtn.TextColor3 = Color3.fromRGB(100, 200, 255)
        else
             strategyBtn.TextColor3 = Color3.fromRGB(255, 220, 100)
        end
    end)
    
    targetBox:GetPropertyChangedSignal("Text"):Connect(function()
        if #targetBox.Text > 1 then targetBox.Text = targetBox.Text:sub(1,1) end
        CONFIG.TargetEnding = targetBox.Text
    end)
    
    resetBtn.MouseButton1Click:Connect(function()
        usedWords = {}
        resetBtn.Text = "CLEARED!"
        task.wait(1)
        resetBtn.Text = "RESET MEMORY"
    end)
    
    -- Status Loop
    task.spawn(function()
        while task.wait(0.2) do
            if screenGui.Parent then
                if isOurTurn() then
                    local timeLeft = CONFIG.RoundDuration - (tick() - TurnStartTime)
                    if timeLeft < CONFIG.PanicThreshold then
                         statusLabel.Text = "PANIC MODE (SPEED UP)!"
                         statusLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
                    else
                         statusLabel.Text = "YOUR TURN (TIME: ".. math.floor(timeLeft)..")"
                         statusLabel.TextColor3 = Color3.fromRGB(0,255,0)
                    end
                else
                    statusLabel.Text = "Scanning UI for words..."
                    statusLabel.TextColor3 = Color3.fromRGB(150,150,150)
                end
            end
        end
    end)
    
    -- Right Ctrl Toggle
    UserInputService.InputBegan:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.RightControl then
            frame.Visible = not frame.Visible
        end
    end)
end

createUltimateUI()
startMonitoring()
