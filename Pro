local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LogService = game:GetService("LogService")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- // ULTIMATE CONFIGURATION \\ --
local CONFIG = {
    Enabled = true,
    
    -- STRATEGY SETTINGS
    Strategy = "Random", 
    TargetEnding = "", 
    
    MinWordLength = 2,
    MaxWordLength = 35,
    
    -- ROUND SETTINGS
    RoundDuration = 15,
    PanicThreshold = 5,
    SafeModeThreshold = 8,
    
    -- HUMANIZATION SETTINGS
    HumanMode = true,        
    SpeedMultiplier = 1.5, 
    
    MistakeChance = 0.08,        
    MicroPauseChance = 0.15,
    SubmitDelay = 0.05, 
    
    VerificationDelay = 0.8,
}

-- // DICTIONARY SYSTEM \\ --
local STARTER_WORDS = {
    A={"apple","about"}, B={"basic","bread"}, C={"catch","clean"}, D={"dance","drive"},
    E={"early","entry"}, F={"faith","field"}, G={"game","great","group","guard","guess"},
    H={"happy","heart"}, I={"image","index"}, J={"joint","judge"}, K={"knife","knock"},
    L={"label","laugh"}, M={"magic","money"}, N={"never","night"}, O={"ocean","order"},
    P={"paper","phone"}, Q={"queen","quiet"}, R={"radio","range"}, S={"scale","sound"},
    T={"table","thing"}, U={"uncle","under"}, V={"value","voice"}, W={"water","world"},
    X={"xenon","xerox"}, Y={"year","young"}, Z={"zebra","zone"}
}

local WORD_DATABASE = STARTER_WORDS
local usedWords = {}

-- [Dictionary Loader]
task.spawn(function()
    local url = "https://raw.githubusercontent.com/Aktron01/jsonwords/refs/heads/main/mainword.json"
    local success, response = pcall(function() return game:HttpGet(url) end)
    
    if not success or not response then 
        warn(" [Ultimate] Download failed. Using starter words.")
        return 
    end

    local newDB = {}
    local count = 0
    
    for word in response:gmatch('"([%a]+)":') do
        if #word >= CONFIG.MinWordLength then
            local first = word:sub(1,1):upper()
            if not newDB[first] then newDB[first] = {} end
            table.insert(newDB[first], word)
            count = count + 1
        end
    end
    
    for letter, list in pairs(STARTER_WORDS) do
        if not newDB[letter] then newDB[letter] = {} end
        for _, word in ipairs(list) do
            table.insert(newDB[letter], word)
        end
    end
    
    if count > 0 then
        WORD_DATABASE = newDB
        print(" [Ultimate] Loaded " .. count .. " words.")
    end
end)

-- // GLOBAL STATE \\ --
local TurnStartTime = 0
local isProcessing = false 
local lastProcessTime = 0 
local currentTurnBase = "" -- [NEW] Stores the game's given root for this turn

-- // LOGIC FUNCTIONS \\ --

local function getValidWord(prefix)
    if not prefix or prefix == "" then return nil end
    local startLetter = prefix:sub(1, 1):upper()
    local words = WORD_DATABASE[startLetter]
    
    if not words then return nil end
    
    local validWords = {}
    local prefixLower = prefix:lower()
    local prefixLen = #prefix
    
    for _, word in ipairs(words) do
        if #word >= prefixLen and #word <= CONFIG.MaxWordLength then
            if word:sub(1, prefixLen):lower() == prefixLower then
                if not usedWords[word:lower()] then
                    table.insert(validWords, word:lower())
                end
            end
        end
    end
    
    -- Desperation Search
    if #validWords == 0 then
        for _, word in ipairs(words) do
            if #word >= prefixLen and #word <= CONFIG.MaxWordLength then
                if word:sub(1, prefixLen):lower() == prefixLower then
                    table.insert(validWords, word:lower())
                end
            end
        end
    end
    
    if #validWords == 0 then return nil end
    
    local timeElapsed = tick() - TurnStartTime
    local timeLeft = CONFIG.RoundDuration - timeElapsed
    local forceShort = false
    
    if timeLeft < CONFIG.SafeModeThreshold then
        forceShort = true
    end
    
    table.sort(validWords, function(a, b)
        if forceShort then return #a < #b end
        
        if CONFIG.Strategy == "Target" and CONFIG.TargetEnding ~= "" then
            local target = CONFIG.TargetEnding:lower()
            local aEnds = a:sub(-1) == target
            local bEnds = b:sub(-1) == target
            if aEnds and not bEnds then return true end
            if not aEnds and bEnds then return false end
        end
        
        if CONFIG.Strategy == "Longest" then return #a > #b end
        if CONFIG.Strategy == "Shortest" then return #a < #b end
        
        return false 
    end)
    
    local selectedWord
    if CONFIG.Strategy == "Random" and not forceShort then
        selectedWord = validWords[math.random(1, #validWords)]
    else
        selectedWord = validWords[1]
    end
    
    return selectedWord
end

local function randomFloat(min, max)
    return min + math.random() * (max - min)
end

local function typeLetter(letter, fastMode)
    local keyCode = Enum.KeyCode[string.upper(letter)]
    if keyCode then
        VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
        if not fastMode then
            task.wait(randomFloat(0.015, 0.035)) 
        end
        VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
    end
end

-- [UPDATED] Smart Clear
local function clearText(count)
    local loopCount = count or 1
    if loopCount < 1 then return end
    
    for i = 1, loopCount do 
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Backspace, false, game)
        task.wait() 
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Backspace, false, game)
    end
end

local function typeWord(word)
    local len = #word
    local targetDuration = 0
    
    if len <= 4 then targetDuration = randomFloat(1.5, 2.5)
    elseif len <= 9 then targetDuration = randomFloat(3.0, 5.0)
    else targetDuration = randomFloat(5.0, 10.0) end
    
    targetDuration = targetDuration * CONFIG.SpeedMultiplier
    local avgDelay = targetDuration / len
    
    for i = 1, len do
        local timeLeft = CONFIG.RoundDuration - (tick() - TurnStartTime)
        local isPanic = timeLeft < CONFIG.PanicThreshold
        
        local letter = string.sub(word, i, i)
        
        if isPanic then
            typeLetter(letter, true)
            task.wait() 
        else
            local currentDelay = avgDelay * randomFloat(0.7, 1.3)
            
            if CONFIG.Strategy ~= "Longest" and math.random() < CONFIG.MicroPauseChance and i > 1 then
                currentDelay = currentDelay + randomFloat(0.15, 0.3)
            end
            
            if math.random() < CONFIG.MistakeChance then
                 local wrongKey = string.char(string.byte(letter) + 1)
                 typeLetter(wrongKey, false)
                 task.wait(randomFloat(0.1, 0.2))
                 VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Backspace, false, game)
                 task.wait(randomFloat(0.05, 0.1))
                 VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Backspace, false, game)
                 task.wait(randomFloat(0.1, 0.2))
            end
            
            task.wait(currentDelay)
            typeLetter(letter, false)
        end
    end
end

local function submitWord()
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
    task.wait(0.02)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
end

-- // GAME STATE DETECTION \\ --

local function getGameFrame()
    local success, frame = pcall(function()
        return PlayerGui.InGame.Frame
    end)
    return success and frame or nil
end

local function scanForUsedWords()
    local frame = getGameFrame()
    if not frame then return end
    
    pcall(function()
        for _, descendant in ipairs(frame:GetDescendants()) do
            if descendant:IsA("TextLabel") and descendant.Visible then
                local text = descendant.Text
                local cleanWord = text:match("^%s*([%a]+)%s*$")
                
                if cleanWord and #cleanWord >= CONFIG.MinWordLength then
                    cleanWord = cleanWord:lower()
                    local firstLetter = cleanWord:sub(1,1):upper()
                    local dictionaryList = WORD_DATABASE[firstLetter]
                    
                    if dictionaryList then
                        if not usedWords[cleanWord] then
                             for _, w in ipairs(dictionaryList) do
                                if w:lower() == cleanWord then
                                    usedWords[cleanWord] = true
                                    break
                                end
                             end
                        end
                    end
                end
            end
        end
    end)
end

local function getRequiredLetterLabel()
    local frame = getGameFrame()
    if not frame then return nil end
    local typeLabel = frame:FindFirstChild("Type")
    if typeLabel and typeLabel:IsA("TextLabel") then
        local text = typeLabel.Text
        local letter = text:match("starting with:%s*(%a)")
        if letter then return letter:upper() end
        letter = text:match("can form a word with:%s*(%a)")
        if letter then return letter:upper() end
    end
    return nil
end

local function getCurrentPrefix()
    local frame = getGameFrame()
    if not frame then return "" end
    local currentWord = frame:FindFirstChild("CurrentWord")
    if not currentWord then return "" end
    
    local text = ""
    local index = 1
    while true do
        local charFrame = currentWord:FindFirstChild(tostring(index))
        if not charFrame then break end
        if charFrame:IsA("Frame") and charFrame.Visible then
            local letterLabel = charFrame:FindFirstChild("Letter")
            if letterLabel then text = text .. letterLabel.Text end
        end
        index = index + 1
    end
    return text
end

local function isOurTurn()
    local frame = getGameFrame()
    if not frame or not frame.Visible then return false end
    
    local circle = frame:FindFirstChild("Circle")
    if not circle or not circle.Visible then return false end
    
    local typeLabel = frame:FindFirstChild("Type")
    if typeLabel and typeLabel:IsA("TextLabel") then
        local text = typeLabel.Text
        if string.find(text, LocalPlayer.DisplayName) or 
           string.find(text, LocalPlayer.Name) or 
           string.find(text:lower(), "your turn") then
            return true
        end
    end
    return false
end

-- // MAIN LOOP \\ --
local lastTurnState = false

local function autoPlay()
    if isProcessing then 
        if tick() - lastProcessTime > 5 then
             isProcessing = false
        end
        return 
    end
    
    if not CONFIG.Enabled then return end
    
    scanForUsedWords()
    
    local myTurn = isOurTurn()
    if myTurn and not lastTurnState then
        TurnStartTime = tick()
        -- [SNAPSHOT] Capture the exact letters given by the game at turn start
        -- Wait a tiny bit for GUI to update
        task.wait(0.1) 
        currentTurnBase = getCurrentPrefix()
        -- If empty, try fallback
        if currentTurnBase == "" then 
            local req = getRequiredLetterLabel()
            if req then currentTurnBase = req end
        end
    end
    lastTurnState = myTurn
    
    if not myTurn then return end
    
    isProcessing = true
    lastProcessTime = tick() 
    
    -- // SAFE RETRY LOOP \\ --
    for attempt = 1, 4 do 
        if not isOurTurn() then break end 
        
        local prefix = getCurrentPrefix()
        
        -- Fallback if prefix is somehow empty but base exists
        if prefix == "" then prefix = currentTurnBase end
        
        if prefix == "" then 
            task.wait(0.2)
        else
            local fullWord = getValidWord(prefix)
            
            -- [SMART RECOVERY LOGIC]
            if not fullWord then 
                -- We only delete if we have typed MORE than the game gave us.
                -- e.g. Game gave "STR" (len 3). Current is "STRX" (len 4).
                -- 4 > 3 -> Delete 1 character.
                if #prefix > #currentTurnBase then
                     local charsToDelete = #prefix - #currentTurnBase
                     -- Limit deletion to avoid spam (max 10)
                     if charsToDelete > 10 then charsToDelete = 10 end
                     
                     clearText(charsToDelete)
                     task.wait(0.3)
                else
                     -- We are at the root (or below it). Do NOT delete.
                     -- Just wait. The dictionary might be missing the word, 
                     -- or the UI hasn't updated.
                     task.wait(0.5)
                end
            else
                -- We found a word!
                local suffix = fullWord:sub(#prefix + 1)
                
                if suffix ~= "" then
                    typeWord(suffix)
                end
                
                task.wait(CONFIG.SubmitDelay)
                submitWord()
                
                -- VERIFICATION
                local checkTime = CONFIG.VerificationDelay
                if attempt > 1 then checkTime = 0.4 end
                
                task.wait(checkTime)
                
                if not isOurTurn() then
                    usedWords[fullWord:lower()] = true
                    break
                else
                    -- Word Failed.
                    usedWords[fullWord:lower()] = true
                    
                    -- Only clear what WE added
                    if suffix ~= "" then
                        clearText(#suffix)
                        task.wait(0.2)
                    end
                end
            end
        end
    end
    
    isProcessing = false
end

local function startMonitoring()
    task.spawn(function()
        while task.wait(0.1) do
            if CONFIG.Enabled then
                local success, err = pcall(autoPlay)
                if not success then
                    warn("AutoPlay Error:", err)
                    isProcessing = false
                end
            end
        end
    end)
end

-- // ULTIMATE GUI CREATION \\ --
local function createUltimateUI()
    if PlayerGui:FindFirstChild("UltimateWordUI") then
        PlayerGui.UltimateWordUI:Destroy()
    end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "UltimateWordUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = PlayerGui
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 220, 0, 280)
    frame.Position = UDim2.new(0, 20, 0.5, -140)
    frame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    frame.BorderSizePixel = 0
    frame.Active = true
    frame.Draggable = true
    frame.Parent = screenGui
    
    local uiCorner = Instance.new("UICorner"); uiCorner.CornerRadius = UDim.new(0, 10); uiCorner.Parent = frame
    
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 30)
    title.BackgroundTransparency = 1
    title.Text = "AutoPlay v8 (Smart Base)"
    title.TextColor3 = Color3.fromRGB(0, 255, 200)
    title.Font = Enum.Font.GothamBlack
    title.TextSize = 13
    title.Parent = frame
    
    -- [Toggle Button]
    local toggleBtn = Instance.new("TextButton")
    toggleBtn.Size = UDim2.new(0.9, 0, 0, 35)
    toggleBtn.Position = UDim2.new(0.05, 0, 0, 40)
    toggleBtn.BackgroundColor3 = CONFIG.Enabled and Color3.fromRGB(0, 180, 100) or Color3.fromRGB(180, 60, 60)
    toggleBtn.Text = CONFIG.Enabled and "STATUS: ACTIVE" or "STATUS: PAUSED"
    toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleBtn.Font = Enum.Font.GothamBold
    toggleBtn.TextSize = 14
    toggleBtn.Parent = frame
    local tCorner = Instance.new("UICorner"); tCorner.CornerRadius = UDim.new(0,6); tCorner.Parent = toggleBtn
    
    -- [Strategy Button]
    local strategyBtn = Instance.new("TextButton")
    strategyBtn.Size = UDim2.new(0.9, 0, 0, 35)
    strategyBtn.Position = UDim2.new(0.05, 0, 0, 85)
    strategyBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 80)
    strategyBtn.Text = "MODE: " .. CONFIG.Strategy:upper()
    strategyBtn.TextColor3 = Color3.fromRGB(255, 220, 100)
    strategyBtn.Font = Enum.Font.GothamBold
    strategyBtn.TextSize = 13
    strategyBtn.Parent = frame
    local sCorner = Instance.new("UICorner"); sCorner.CornerRadius = UDim.new(0,6); sCorner.Parent = strategyBtn

    -- [Target Box]
    local targetLabel = Instance.new("TextLabel")
    targetLabel.Size = UDim2.new(1, 0, 0, 15)
    targetLabel.Position = UDim2.new(0, 0, 0, 125)
    targetLabel.Text = "Target Ending Letter:"
    targetLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    targetLabel.BackgroundTransparency = 1
    targetLabel.Font = Enum.Font.Gotham
    targetLabel.TextSize = 11
    targetLabel.Parent = frame

    local targetBox = Instance.new("TextBox")
    targetBox.Size = UDim2.new(0.9, 0, 0, 30)
    targetBox.Position = UDim2.new(0.05, 0, 0, 145)
    targetBox.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    targetBox.Text = ""
    targetBox.PlaceholderText = "e.g. 'x'"
    targetBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    targetBox.Font = Enum.Font.Gotham
    targetBox.TextSize = 12
    targetBox.Parent = frame
    local tbCorner = Instance.new("UICorner"); tbCorner.CornerRadius = UDim.new(0,6); tbCorner.Parent = targetBox

    -- [Reset Memory]
    local resetBtn = Instance.new("TextButton")
    resetBtn.Size = UDim2.new(0.9, 0, 0, 30)
    resetBtn.Position = UDim2.new(0.05, 0, 0, 185)
    resetBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 50)
    resetBtn.Text = "RESET MEMORY"
    resetBtn.TextColor3 = Color3.fromRGB(255, 200, 200)
    resetBtn.Font = Enum.Font.GothamBold
    resetBtn.TextSize = 12
    resetBtn.Parent = frame
    local rCorner = Instance.new("UICorner"); rCorner.CornerRadius = UDim.new(0,6); rCorner.Parent = resetBtn

    -- [Status Info]
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Size = UDim2.new(1, 0, 0, 20)
    statusLabel.Position = UDim2.new(0, 0, 0, 225)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Text = "Waiting..."
    statusLabel.TextColor3 = Color3.fromRGB(120, 120, 120)
    statusLabel.Font = Enum.Font.Gotham
    statusLabel.TextSize = 11
    statusLabel.Parent = frame

    -- Events
    toggleBtn.MouseButton1Click:Connect(function()
        CONFIG.Enabled = not CONFIG.Enabled
        toggleBtn.BackgroundColor3 = CONFIG.Enabled and Color3.fromRGB(0, 180, 100) or Color3.fromRGB(180, 60, 60)
        toggleBtn.Text = CONFIG.Enabled and "STATUS: ACTIVE" or "STATUS: PAUSED"
    end)
    
    local strategies = {"Shortest", "Longest", "Target", "Random"}
    local sIndex = 1
    
    strategyBtn.MouseButton1Click:Connect(function()
        sIndex = sIndex + 1
        if sIndex > #strategies then sIndex = 1 end
        CONFIG.Strategy = strategies[sIndex]
        strategyBtn.Text = "MODE: " .. CONFIG.Strategy:upper()
        
        if CONFIG.Strategy == "Longest" then
             strategyBtn.TextColor3 = Color3.fromRGB(255, 100, 255)
        elseif CONFIG.Strategy == "Target" then
             strategyBtn.TextColor3 = Color3.fromRGB(100, 200, 255)
        else
             strategyBtn.TextColor3 = Color3.fromRGB(255, 220, 100)
        end
    end)
    
    targetBox:GetPropertyChangedSignal("Text"):Connect(function()
        if #targetBox.Text > 1 then targetBox.Text = targetBox.Text:sub(1,1) end
        CONFIG.TargetEnding = targetBox.Text
    end)
    
    resetBtn.MouseButton1Click:Connect(function()
        usedWords = {}
        resetBtn.Text = "CLEARED!"
        task.wait(1)
        resetBtn.Text = "RESET MEMORY"
    end)
    
    -- Status Loop
    task.spawn(function()
        while task.wait(0.2) do
            if screenGui.Parent then
                if isOurTurn() then
                    local timeLeft = CONFIG.RoundDuration - (tick() - TurnStartTime)
                    if timeLeft < CONFIG.PanicThreshold then
                         statusLabel.Text = "PANIC MODE (SPEED UP)!"
                         statusLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
                    else
                         statusLabel.Text = "YOUR TURN (TIME: ".. math.floor(timeLeft)..")"
                         statusLabel.TextColor3 = Color3.fromRGB(0,255,0)
                    end
                else
                    statusLabel.Text = "Scanning UI for words..."
                    statusLabel.TextColor3 = Color3.fromRGB(150,150,150)
                end
            end
        end
    end)
    
    -- Right Ctrl Toggle
    UserInputService.InputBegan:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.RightControl then
            frame.Visible = not frame.Visible
        end
    end)
end

createUltimateUI()
startMonitoring()
